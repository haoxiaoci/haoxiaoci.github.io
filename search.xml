<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>All This I Did Without You</title>
      <link href="/archives/7f473fb4.html"/>
      <url>/archives/7f473fb4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 27 2019 13:37:43 GMT+0800 (GMT+08:00) --><p>最近在&lt;见信如晤&gt;上听到抖森(Tom Hiddleston)读这封信，即幽默又深情，很是喜欢，所以抄了过来记录一下。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><p>这封信的作者叫Gerald Durrell（杰拉尔德·德雷尔）</p><p>一位英国动物学家、主持人和作家，泽西动物园的创办人。这封信是1978年他写给未婚妻Lee McGeorge的情书，信的后半段大量的对大自然的描述，也是因为作者是动物学家的缘故，中间穿插了些英式幽默，整封信就像一首诗。</p><p>一年后，他俩结婚了。两人多次到世界各地远足探险，并合作写了两本书。</p><p><img src="https://upload-images.jianshu.io/upload_images/7770956-851347d527b3f9e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作者.jpg"></p><p>嗯，是的，你没看错，两人好像年龄相差很大的样子，小声说(他俩差24岁)，两个人一生致力于野生动物保护事业，</p><h3 id="All-This-I-Did-Without-You"><a href="#All-This-I-Did-Without-You" class="headerlink" title="All This I Did Without You"></a>All This I Did Without You</h3><font color="black" size="4">未与你共度一切</font><p>朗读者：Tom Hiddleston</p><p>July 31st, 1978</p><p>1978年7月31日</p><p>My darling McGeorge,</p><p>亲爱的麦克乔治：</p><p>You said that things seemed clearer when they were written down.</p><p>你曾说过把事情写下来，他们就会变得更清楚。</p><p>Well, here with a very boring letter in which I will try and put everything down so that you may read and re-read at horror at your folly in getting involved with me.</p><p>那么这恐怕是一封很无聊的信，在信里我会试着把所有的东西都写下来，因此你会在恐惧中反复阅读，为爱上我而感到愚蠢。</p><p>Deep breath.</p><p>深呼吸。</p><p>To begin with I love you with a depth and passion that I have felt for no one else in this life and if it astonishes you it astonishes me as well.</p><p>首先，我如此深切热烈的爱你，以至于我此生不会再爱上其他人，如果这让你吃惊，它同样让我觉得不可思议。</p><p>Not, I hasten to say, because you are not worth loving.</p><p>我必须要说，并不是你不值得去爱。</p><p>Far from it.</p><p>远不是如此。</p><p>It’s just that, first of all, I swore I would not get involved with another woman.</p><p>只是，首先我发誓我不会再爱上另外一个女人。</p><p>Secondly, I have never had such a feeling before and it is almost frightening.</p><p>其次，我从未有过这样的感觉，因而感到害怕。</p><p>Thirdly, I would never have thought it possible that another human being could occupy my waking (and sleeping) thoughts to the exclusion of almost everything else.</p><p>第三，我从未想过会有一个人会占据我所有的时间（包括睡觉的时候）让我无时无刻不在想她。</p><p>Fourthly, I never thought that – even if one was in love – one could get so completely besotted with another person, so that a minute away from them felt like a thousand years.</p><p>第四，我从未想过会有人，即使是处于恋爱中的人，会如此迷恋对方，以至于分开哪怕一分钟都像相隔千年。</p><p>Fifthly, I never hoped, aspired, dreamed that one could find everything one wanted in one person.</p><p>第五，我从未希望、渴求、幻想过能在另外一个人身上得到我想要的一切。</p><p>I was not such an idiot as to believe this was possible.</p><p>我还没有愚蠢到认为这是可能的。</p><p>Yet in you I have found everything I want: you are beautiful, gay, giving, gentle, idiotically and deliciously feminine, sexy, wonderfully intelligent and wonderfully silly as well.</p><p>但是在你身上我找到了我想要的一切：你不但温柔美丽，还性格随和乐于助人，你性感撩人、聪明机灵中还带着点傻里傻气的天真。</p><p>I want nothing else in this life than to be with you, to listen and watch you (your beautiful voice, your beauty), to argue with you, to laugh with you, to show you things and share things with you, to explore your magnificent mind, to explore your wonderful body, to help you, protect you, serve you, and bash you on the head when I think you are wrong …</p><p>我这辈子只想和你在一起，聆听你的动人声音，欣赏你的美丽容颜，与你同甘共苦，分享生活点滴，探索你的浩渺思绪和曼妙身姿，帮助你，保护你，服务你，在我认为你犯错了的时候念叨你……</p><p>Not to put too fine a point on it I consider that I am the only man outside mythology to have found the crock of gold at the rainbow’s end.</p><p>坦白来说，我认为我是唯一一个在神话中的彩虹尽头发现了金匣子的人。</p><p>But – having said all that – let us consider things in detail.</p><p>但是说完这些，让我们从细节角度考虑。</p><p>Don’t let this become public but … well, I have one or two faults.</p><p>不要公开这件事……但是确实，我会犯一回两回错。</p><p>Minor ones, I hasten to say.</p><p>甚至更多小错误，我必须承认。</p><p>For example, I am inclined to be overbearing.</p><p>比如说，我有时候会有些蛮横。</p><p>I do it for the best possible motives (all tyrants say that) but I do tend (without thinking) to tread people underfoot.</p><p>我这么做的目的是好的（所有的暴君都这么说），但是我确实容易（不加思考）忽略别人的想法。</p><p>You must tell me when I am doing it to you, my sweet, because it can be a very bad thing in a marriage.</p><p>亲爱的，当我对你这么做的时候你一定要告诉我，因为这会是一段婚姻中非常糟糕的事情。</p><p>Right. Second blemish.</p><p>那么，第二个缺点。</p><p>This, actually, is not so much a blemish of character as a blemish of circumstance.</p><p>这其实是一个形势的瑕疵而不是一个人性格上的瑕疵。</p><p>Darling I want you to be you in your own right and I will do everything I can to help you in this.</p><p>亲爱的我希望你有做自己的权利，为此我会尽我所能来帮助你。</p><p>But you must take into consideration that I am also me in my own right and that I have a headstart on you …</p><p>但同样的你也要考虑到我也有做自己的权利，而且我比你有优势……</p><p>What I am trying to say is that you must not feel offended if you are sometimes treated simply as my wife.</p><p>我想说的是，如果有的时候我怠慢了你，你千万不要气恼。</p><p>Always remember that what you lose on the swings you gain on the roundabouts.</p><p>要时刻记住失之东隅，收之桑榆。</p><p>But I am an established ‘creature’ in the world, and so – on occasions – you will have to live in my shadow.</p><p>然而我在世界上算是一个“知名”人物，有时你可能会活在我的光环之下。</p><p>Nothing gives me less pleasure than this but it is a fact of life that has to be faced.</p><p>这是让我最不开心的一件事，但是我们却都要面对。</p><p>Third (and very important and nasty) blemish: jealousy.</p><p>第三个缺点（非常重要和严重）：嫉妒。</p><p>I don’t think you know what jealousy is (thank God) in the real sense of the word.</p><p>我认为你并不知道嫉妒的真正含义（感谢上帝）。</p><p>I know that you have felt jealousy over Lincoln’s wife and child, but this is what I call normal jealousy, and this – to my regret – is not what I’ve got.</p><p>我知道你肯定羡慕过林肯的妻子和孩子，这种是我所说的一般嫉妒，但这很遗憾也是我没能得到的。</p><p>What I have got is a black monster that can pervert my good sense, my good humour and any goodness that I have in my make-up.</p><p>我得到的是一个能够扭曲我的想法、幽默和善良的邪恶怪物。</p><p>It is really a Jekyll and Hyde situation … my Hyde is stronger than my good sense and defeats me, hard though I try.</p><p>这是一个双重人格的情况……我的邪恶面要比我的善良面更强，并且打败了我，尽管我尽力反抗也于事无补。</p><p>As I told you, I have always known that this lurks within me, but I could control it, and my monster slumbered and nothing happened to awake it.</p><p>正如我告诉你的一样，我一直知道这些潜伏在我心中，我能控制它，我内心的怪物正蛰伏，却没有任何事物能够唤醒它。</p><p>Then I met you and I felt my monster stir and become half awake when you told me of Lincoln and others you have known, and with your letter my monster came out of its lair, black, irrational, bigoted, stupid, evil, malevolent.</p><p>之后我遇见了你，我心中的怪物苏醒了，并且在你告诉我林肯以及其他你认识的人的时候就已经半醒了，随着你的信，我心中那黑暗的、不理性的、偏执的、愚蠢的、邪恶的怪物走出了它的兽穴。</p><p>You will never know how terribly corrosive jealousy is; it is a physical pain as though you had swallowed acid or red hot coals.</p><p>你不会知道恶毒的嫉妒会有多么糟糕，那像是喝下迷幻药或者是烧红煤块带来的痛。</p><p>It is the most terrible of feelings.</p><p>这是最糟糕的感觉。</p><p>But you can’t help it – at least I can’t, and God knows I’ve tried.</p><p>但是你却无能为力——至少我不行，上帝知道我尝试过了。</p><p>I don’t want any ex-boyfriends sitting in church when I marry you.</p><p>当我迎娶你的时候，我可不想有任何一位男朋友坐在教堂里面。</p><p>On our wedding day I want nothing but happiness, both for you and me, and I know I won’t be happy if there is a church full of your ex-conquests.</p><p>在我们结婚的那天，我只希望你我都幸福，但是我知道，如果教堂里都是你的前任，我是不会高兴的。</p><p>When I marry you I will have no past, only a future: I don’t want to drag my past into our future and I don’t want you to do it, either.</p><p>当我娶你的时候，我们就忘掉过去，只看到未来：我不想我的过去介入我们的未来，我同样不希望你的过去介入。</p><p>Remember I am jealous of you because I love you.</p><p>记住，我嫉妒你，是因为我爱你。</p><p>You are never jealous of something you don’t care about.</p><p>你不会嫉妒任何你不关心的事。</p><p>O.K. enough about jealousy.</p><p>好了，关于嫉妒就到这里。</p><p>Now let me tell you something.</p><p>现在我要告诉你一些事情。</p><p>I have seen a thousand sunsets and sunrises, on land where it floods forest and mountains with honey coloured light,</p><p>我看过无数次日出日落，在大地上，森林和群山都被笼罩在光芒之中，</p><p>at sea where it rises and sets like a blood orange in a multicoloured nest of cloud, slipping in and out of the vast ocean.</p><p>在大海上，为五彩的云朵增添上一抹血橘色，在无垠的大海上划进划出。</p><p>I have seen a thousand moons: harvest moons like gold coins, winter moons as white as ice chips, new moons like baby swans’ feathers.</p><p>我看过无数次月亮：满月如金币，寒月洁白似冰屑，新月宛如小天鹅的羽毛。</p><p>I have seen seas as smooth as if painted, coloured like shot silk or blue as a kingfisher or transparent as glass or black and crumpled with foam, moving ponderously and murderously.</p><p>我看过大海平静如止，颜色如缎，或蓝如翠鸟，或如玻璃般透明，抑或如乌黑褶皱的泡沫，沉重而危险的翻动着。</p><p>I have felt winds straight from the South Pole, bleak and wailing like a lost child; winds as tender and warm as a lover’s breath;</p><p>我感受过来自南极的烈风，寒冷呼啸着像一个走失的儿童；感受过如爱人呼吸般的柔风；</p><p>winds that carried the astringent smell of salt and the death of seaweeds; winds that carried the moist rich smell of a forest floor, the smell of a million flowers.</p><p>掺杂着苦涩的咸味和海草死亡气息的海风；弥散着森林大地肥沃土壤气息和千万种花香的山风。</p><p>Fierce winds that churned and moved the sea like yeast, or winds that made the waters lap at the shore like a kitten.</p><p>狂风涛海如同酵母发酵起沫，或使海水轻拍海岸像小猫一般。</p><p>I have known silence: the cold, earthy silence at the bottom of a newly dug well; the implacable stony silence of a deep cave;</p><p>我了解宁静：一口新井中寒冷又朴实的宁静；一个深洞中无情冷酷的宁静；</p><p>the hot, drugged midday silence when everything is hypnotised and stilled into silence by the eye of the sun; the silence when great music ends.</p><p>炎热迷离的午后万物被炎炎烈日催眠的宁静；一曲美妙音乐结束的宁静。</p><p>I have heard summer cicadas cry so that the sound seems stitched into your bones.</p><p>我听过夏日蝉鸣如芒在骨。</p><p>I have heard tree frogs in an orchestration as complicated as Bach singing in a forest lit by a million emerald fireflies.</p><p>我听过树蛙在无数萤火虫点亮的森林中演奏着如巴赫管弦乐般美妙复杂的旋律。</p><p>I have heard the Keas calling over grey glaciers that groaned to themselves like old people as they inched their way to the sea.</p><p>我听过啄羊鹦鹉飞跃冰川叫喊着，像老人呻吟着走向大海。</p><p>I have heard the hoarse street vendor cries of the mating Fur seals as they sang to their sleek golden wives,</p><p>我听过声嘶力竭的街道商贩成交皮草生意的叫嚷，好像是对他们鎏金妻子的赞美；</p><p>the crisp staccato admonishment of the Rattlesnake, the cobweb squeak of the Bat and the belling roar of the Red deer knee-deep in purple heather.</p><p>响尾蛇清脆却不连贯的警告声；成群结队的蝙蝠的刺耳叫声；马鹿在齐膝的紫石楠中的咆哮。</p><p>I have heard Wolves baying at a winter’s moon, Red howlers making the forest vibrate with their roaring cries.</p><p>我听过狼群在冬夜对月长嚎，红吼候啸震山林。</p><p>I have heard the squeak, purr and grunt of a hundred multi-coloured reef fishes.</p><p>我听过珊瑚群中异彩斑斓的鱼群发出的吱吱、呱呱和呢喃。</p><p>I have seen hummingbirds flashing like opals round a tree of scarlet blooms, humming like a top.</p><p>我见过蜂鸟如同宝石一般围绕着开红花的树闪烁，如陀螺一般哼鸣作响。</p><p>I have seen flying fish, skittering like quicksilver across the blue waves, drawing silver lines on the surface with their tails.</p><p>我见过飞鱼如水银一般穿越蓝色海浪，用他们的尾翼在海面上划下银色痕迹。</p><p>I have seen Spoonbills flying home to roost like a scarlet banner across the sky.</p><p>我见过琵鹭像朱红的旗帜从鸟巢飞往鸟群。</p><p>I have seen Whales, black as tar, cushioned on a cornflower blue sea, creating a Versailles of fountain with their breath.</p><p>我见过漆黑洳焦的鲸鱼，在如矢车菊般的蓝色海洋中停留，呼吸间创造了一个凡尔赛宫的喷泉。</p><p>I have watched butterflies emerge and sit, trembling, while the sun irons their wings smooth.</p><p>我见过阳光熨展蝴蝶的翅膀，它浮现、停顿、又扇动。</p><p>I have watched Tigers, like flames, mating in the long grass.</p><p>我见过鲜如火焰的老虎在长草之中亲昵。</p><p>I have been dive-bombed by an angry Raven, black and glossy as the Devil’s hoof.</p><p>我曾被愤怒的乌鸦俯冲攻击，如魔鬼的爪牙黑暗顺滑。</p><p>I have lain in water warm as milk, soft as silk, while around me played a host of Dolphins.</p><p>我曾躺在温暖如牛奶、柔顺如丝绸的水中，任一群海豚在我身边嬉戏。</p><p>I have met a thousand animals and seen a thousand wonderful things …</p><p>我曾遇到过无数生灵，曾看过无数美景……</p><p>All this I did without you.</p><p>这一切却未与你共度。</p><p>This was my loss.</p><p>这都会是我的损失。</p><p>All this I want to do with you.</p><p>这些事情我都想与你共度。</p><p>This will be my gain.</p><p>这一切才会是我的收获。</p><p>All this I would gladly have forgone for the sake of one minute of your company, for your laugh, your voice, your eyes, hair, lips, body,</p><p>为了有你一分钟的陪伴，我愿放弃这一切，为你的笑声，你的声音，你的眼睛，头发，嘴唇，身体，</p><p>and above all for your sweet, ever surprising mind which is an enchanting quarry in which it is my privilege to delve.</p><p>尤其是你善良又令人惊喜的心，那时只有我有权利开采的宝藏。</p><h3 id="抖森读信视频"><a href="#抖森读信视频" class="headerlink" title="抖森读信视频"></a>抖森读信视频</h3><iframe name="myframe" width="100%" height="480" src="//player.bilibili.com/player.html?aid=22518688&cid=37331713&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen onload="document.all.myframe.style.width=myframe.document.body.scrollWidth"></iframe><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>python格式化整理</title>
      <link href="/archives/eacda3be.html"/>
      <url>/archives/eacda3be.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 27 2019 13:37:43 GMT+0800 (GMT+08:00) --><p>python项目为了保持易读性，可维护性，做了代码格式规范，我大概总结了一下这些在格式化python代码中常用到的工具；</p><h2 id="pep8"><a href="#pep8" class="headerlink" title="pep8"></a>pep8</h2><p>link：</p><p>pep8官方网站：<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p><p>中文翻译版：<a href="https://alvinzhu.xyz/2017/10/07/python-pep-8/#top" target="_blank" rel="noopener">https://alvinzhu.xyz/2017/10/07/python-pep-8/#top</a></p><h2 id="pycodestyle"><a href="#pycodestyle" class="headerlink" title="pycodestyle"></a>pycodestyle</h2><p>link：</p><p><a href="https://pycodestyle.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://pycodestyle.readthedocs.io/en/latest/</a></p><p><a href="https://github.com/PyCQA/pycodestyle" target="_blank" rel="noopener">https://github.com/PyCQA/pycodestyle</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>pycodestyle is a tool to check your Python code against some of the style conventions in PEP 8.</p><p>pycodestyle是一个检查python代码是否匹配pep8风格的工具</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>Plugin architecture: Adding new checks is easy(插件结构，安装起来很方便)</li><li>Parseable output: Jump to error location in your editor.(输出易读，直接指出错误代码的位置)</li><li>Small: Just one Python file, requires only stdlib. You can use just the pycodestyle.py file for this purpose.(安装文件小，就一个python脚本，外加依赖一个库stdlib)</li><li>Comes with a comprehensive test suite.(代码检查很全面)</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pycodestyle</span><br><span class="line">pip install --upgrade pycodestyle # 安装或更新，下文中其他包的安装更新，亦是如此，不再重复</span><br><span class="line">pip uninstall pycodestyle   # 卸载包，下文中其他包的卸载，亦是如此，不再重复</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle --first optparse.py</span><br><span class="line">optparse.py:69:11: E401 multiple imports on one line</span><br><span class="line">optparse.py:77:1: E302 expected 2 blank lines, found 1</span><br><span class="line">optparse.py:88:5: E301 expected 1 blank line, found 0</span><br><span class="line">optparse.py:222:34: W602 deprecated form of raising exception</span><br><span class="line">optparse.py:347:31: E211 whitespace before &apos;(&apos;</span><br><span class="line">optparse.py:357:17: E201 whitespace after &apos;&#123;&apos;</span><br><span class="line">optparse.py:472:29: E221 multiple spaces before operator</span><br><span class="line">optparse.py:544:21: W601 .has_key() is deprecated, use &apos;in&apos;</span><br></pre></td></tr></table></figure><p>使用pycodestyle检查pep8语法的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle --show-source --show-pep8 testsuite/E40.py</span><br><span class="line">testsuite/E40.py:2:10: E401 multiple imports on one line</span><br><span class="line">import os, sys</span><br><span class="line">         ^</span><br><span class="line">    Imports should usually be on separate lines.</span><br><span class="line">    </span><br><span class="line">    Okay: import os\nimport sys</span><br><span class="line">    E401: import sys, os</span><br></pre></td></tr></table></figure><p>统计状态码出现的次数：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle --statistics -qq Python-2.5/Lib</span><br><span class="line">232     E201 whitespace after &apos;[&apos;</span><br><span class="line">599     E202 whitespace before &apos;)&apos;</span><br><span class="line">631     E203 whitespace before &apos;,&apos;</span><br><span class="line">842     E211 whitespace before &apos;(&apos;</span><br><span class="line">2531    E221 multiple spaces before operator</span><br><span class="line">4473    E301 expected 1 blank line, found 0</span><br><span class="line">4006    E302 expected 2 blank lines, found 1</span><br><span class="line">165     E303 too many blank lines (4)</span><br><span class="line">325     E401 multiple imports on one line</span><br><span class="line">3615    E501 line too long (82 characters)</span><br><span class="line">612     W601 .has_key() is deprecated, use &apos;in&apos;</span><br><span class="line">1188    W602 deprecated form of raising exception</span><br></pre></td></tr></table></figure><p></p><p>官方的介绍更详细一点，实在是懒得翻译：<br><a href="https://pycodestyle.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">https://pycodestyle.readthedocs.io/en/latest/intro.html</a></p><h2 id="flake8"><a href="#flake8" class="headerlink" title="flake8"></a>flake8</h2><p>link:</p><p><a href="http://flake8.pycqa.org/en/latest/" target="_blank" rel="noopener">http://flake8.pycqa.org/en/latest/</a></p><p><a href="https://pypi.org/project/flake8/" target="_blank" rel="noopener">https://pypi.org/project/flake8/</a></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Flake8 是由Python官方发布的一款辅助检测Python代码是否规范的工具，相对于目前热度比较高的Pylint来说，Flake8检查规则灵活，支持集成额外插件，扩展性强。Flake8是对下面三个工具的封装：</p><ol><li>PyFlakes：静态检查Python代码逻辑错误的工具。github:<a href="https://github.com/pycqa/pyflakes" target="_blank" rel="noopener">https://github.com/pycqa/pyflakes</a></li><li>Pep8： 静态检查PEP8编码风格的工具。</li><li>NedBatchelder’s McCabe ：静态分析Python代码复杂度的工具。github: <a href="https://github.com/pycqa/mccabe" target="_blank" rel="noopener">https://github.com/pycqa/mccabe</a><br>不光对以上三个工具的封装，Flake8还提供了扩展的开发接口。</li></ol><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flake8</span><br></pre></td></tr></table></figure><p>官方的安装解释：<a href="http://flake8.pycqa.org/en/latest/index.html#installation-guide" target="_blank" rel="noopener">http://flake8.pycqa.org/en/latest/index.html#installation-guide</a></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flake8 a.py</span><br></pre></td></tr></table></figure><p>一台机器上安装了多个版本的python时，指定python的版本使用flake8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例1：python3.5 -m flake8</span><br><span class="line">举例2：python2.7 -m flake8</span><br></pre></td></tr></table></figure><p>使用flake8对一个项目做语法检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flake8 my_project/</span><br></pre></td></tr></table></figure><h3 id="选项与配置文件"><a href="#选项与配置文件" class="headerlink" title="选项与配置文件"></a>选项与配置文件</h3><p>关于flake8 –help的哪些options的解释：<a href="http://flake8.pycqa.org/en/latest/user/options.html" target="_blank" rel="noopener">http://flake8.pycqa.org/en/latest/user/options.html</a></p><p>flake8的options配置每次在使用的时候写到命令行有点麻烦，可以写到配置文件中，在一个project中支持的配置文件：<strong>setup.cfg, tox.ini, or .flake8</strong>.<br>并不是所有的命令行配置的options都可以写到配置文件里，<br>举个例子，命令行转换到配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flake8 --ignore D203 \</span><br><span class="line">         --exclude .git,__pycache__,docs/source/conf.py,old,build,dist \</span><br><span class="line">         --max-complexity 10</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[flake8]</span><br><span class="line">ignore = D203</span><br><span class="line">exclude = .git,__pycache__,docs/source/conf.py,old,build,dist</span><br><span class="line">max-complexity = 10</span><br></pre></td></tr></table></figure><p>规范一点的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[flake8]</span><br><span class="line">ignore = D203</span><br><span class="line">exclude =</span><br><span class="line">    .git,</span><br><span class="line">    __pycache__,</span><br><span class="line">    docs/source/conf.py,</span><br><span class="line">    old,</span><br><span class="line">    build,</span><br><span class="line">    dist</span><br><span class="line">max-complexity = 10</span><br></pre></td></tr></table></figure><p>如果你愿意，也可以加上注释，这样可读性更好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[flake8]</span><br><span class="line">ignore = D203</span><br><span class="line">exclude =</span><br><span class="line">    # No need to traverse our git directory</span><br><span class="line">    .git,</span><br><span class="line">    # There&apos;s no value in checking cache directories</span><br><span class="line">    __pycache__,</span><br><span class="line">    # The conf file is mostly autogenerated, ignore it</span><br><span class="line">    docs/source/conf.py,</span><br><span class="line">    # The old directory contains Flake8 2.0</span><br><span class="line">    old,</span><br><span class="line">    # This contains our built documentation</span><br><span class="line">    build,</span><br><span class="line">    # This contains builds of flake8 that we don&apos;t want to check</span><br><span class="line">    dist</span><br><span class="line">max-complexity = 10</span><br></pre></td></tr></table></figure><p>当你有很多配置的时候注释呢，作用还是很大的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[flake8]</span><br><span class="line"># it&apos;s not a bug that we aren&apos;t using all of hacking, ignore:</span><br><span class="line"># F812: list comprehension redefines ...</span><br><span class="line"># H101: Use TODO(NAME)</span><br><span class="line"># H202: assertRaises Exception too broad</span><br><span class="line"># H233: Python 3.x incompatible use of print operator</span><br><span class="line"># H301: one import per line</span><br><span class="line"># H306: imports not in alphabetical order (time, os)</span><br><span class="line"># H401: docstring should not start with a space</span><br><span class="line"># H403: multi line docstrings should end on a new line</span><br><span class="line"># H404: multi line docstring should start without a leading new line</span><br><span class="line"># H405: multi line docstring summary not separated with an empty line</span><br><span class="line"># H501: Do not use self.__dict__ for string formatting</span><br><span class="line">ignore = F812,H101,H202,H233,H301,H306,H401,H403,H404,H405,H501</span><br></pre></td></tr></table></figure><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>Flake8 基础错误返回码一共有三类：</p><ol><li>E<strong><em>/W</em></strong>：PEP8 中的 error 和 warning。</li><li>F***：通过 PyFlakes 检测出的 error，其实 PyFlakes 本身是不提供错误返回码的，flake8 对 pyflakes 返回的错误消息进行了分类。</li><li>C9**：通过 McCabe 检测出的代码复杂度。</li></ol><p>关于返回错误码的具体解释：<br>F开头的： <a href="http://flake8.pycqa.org/en/latest/user/error-codes.html" target="_blank" rel="noopener">http://flake8.pycqa.org/en/latest/user/error-codes.html</a><br>E和W开头的错：<a href="https://pycodestyle.readthedocs.io/en/latest/intro.html#error-codes" target="_blank" rel="noopener">https://pycodestyle.readthedocs.io/en/latest/intro.html#error-codes</a><br>C开头的，代码的复杂度是怎么计算的：<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cyclomatic_complexity</a><br>pyCodeStyle: <a href="http://pycodestyle.pycqa.org" target="_blank" rel="noopener">http://pycodestyle.pycqa.org</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>flake8的插件查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip search flake8</span><br></pre></td></tr></table></figure><p>推荐使用的插件：<br>hacking<br>pep8-naming<br>flake8-chart</p><h2 id="hacking"><a href="#hacking" class="headerlink" title="hacking"></a>hacking</h2><p>link：</p><p><a href="https://pypi.python.org/pypi/hacking" target="_blank" rel="noopener">https://pypi.python.org/pypi/hacking</a><br><a href="https://docs.openstack.org/hacking/latest/user/index.html" target="_blank" rel="noopener">https://docs.openstack.org/hacking/latest/user/index.html</a></p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>hacking就是flake8的一个插件，主要用来把代码规范为openstack style 的格式</p><p>hacking最初是基于nova的第一个commit，基于google python style的，后来逐渐增加了openstack style的一些规则，hacking主要实现了规则如下：</p><ol><li>Agree on a common style guide so reviews don’t get bogged down on style nit picks. (example: docstring guidelines)</li><li>Make code written by many different authors easier to read by making the style more uniform. (example: unix vs windows newlines)</li><li>Call out dangerous patterns and avoid them. (example: shadowing built-in or reserved words)</li></ol><p>大致意思：</p><ol><li>统一一个共同的风格指南，所以评论不用再挑选书写的风格。 （例如：docstring指南）</li><li>通过使样式更加统一，使许多不同作者编写的代码更容易阅读。 （例如：unix vs windows newlines）</li><li>指出危险模式并避免它们。 （例如：遮蔽内置或保留字）<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install hacking</span><br></pre></td></tr></table></figure><p>hacking依赖于flake8,并且自己没有单独的命令，安装完后，执行flake8检查python脚本时，会有一堆H开头的错误，是hacking插件的；</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>hacking的使用：</p><p><a href="https://docs.openstack.org/hacking/latest/user/usage.html" target="_blank" rel="noopener">https://docs.openstack.org/hacking/latest/user/usage.html</a></p><h3 id="什么是openstack-style"><a href="#什么是openstack-style" class="headerlink" title="什么是openstack style"></a>什么是openstack style</h3><p><a href="https://docs.openstack.org/hacking/latest/user/hacking.html" target="_blank" rel="noopener">openstack style guidelines</a></p><h2 id="yapf"><a href="#yapf" class="headerlink" title="yapf"></a>yapf</h2><p>link：</p><p><a href="https://github.com/google/yapf" target="_blank" rel="noopener">https://github.com/google/yapf</a></p><p><a href="https://pypi.org/project/yapf/" target="_blank" rel="noopener">https://pypi.org/project/yapf/</a></p><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>yapf(Yet Another Python Formatter)是Google开源的一个用来格式化Python代码的工具. 支持2种代码规范(PEP8和Google style)</p><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install yapf</span><br></pre></td></tr></table></figure><h3 id="返回状态码"><a href="#返回状态码" class="headerlink" title="返回状态码"></a>返回状态码</h3><p>还有返回状态码呢，当执行成功时返回0，否则返回非0数值<br>使用–diff 选项，当没有文件无变化是返回0，否则返回非0<br>这个特性可以用CI(持续集成)</p><h3 id="yapfignore"><a href="#yapfignore" class="headerlink" title=".yapfignore"></a>.yapfignore</h3><p>类似于.gitignore</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可配置在命令行，使用–style(可选择pep8或google)，其他参数可使用{key:value}这种字典的格式写到命令行中<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--style=&apos;&#123;based_on_style: chromium, indent_width: 4&#125;&apos;</span><br></pre></td></tr></table></figure><p>写到配置文件中举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[yapf]</span><br><span class="line">based_on_style = pep8</span><br><span class="line">spaces_before_comment = 4</span><br><span class="line">split_before_logical_operator = true</span><br></pre></td></tr></table></figure><h4 id="配置的优先级选择："><a href="#配置的优先级选择：" class="headerlink" title="配置的优先级选择："></a>配置的优先级选择：</h4><p>默认选择pep8</p><ol><li>Specified on the command line</li><li>In the [style] section of a .style.yapf file in either the current directory or one of its parent directories.</li><li>In the [yapf] section of a setup.cfg file in either the current directory or one of its parent directories.</li><li>In the ~/.config/yapf/style file in your home directory.</li></ol><h4 id="导出当前的配置文件"><a href="#导出当前的配置文件" class="headerlink" title="导出当前的配置文件"></a>导出当前的配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yapf --style-help &gt;yapf-style.config</span><br></pre></td></tr></table></figure><h3 id="简单使用举例"><a href="#简单使用举例" class="headerlink" title="简单使用举例"></a>简单使用举例</h3><p>原来的ugly code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;  &apos;a&apos;:37,&apos;b&apos;:42,</span><br><span class="line"></span><br><span class="line">&apos;c&apos;:927&#125;</span><br><span class="line"></span><br><span class="line">y = &apos;hello &apos;&apos;world&apos;</span><br><span class="line">z = &apos;hello &apos;+&apos;world&apos;</span><br><span class="line">a = &apos;hello &#123;&#125;&apos;.format(&apos;world&apos;)</span><br><span class="line">class foo  (     object  ):</span><br><span class="line">  def f    (self   ):</span><br><span class="line">    return       37*-+2</span><br><span class="line">  def g(self, x,y=42):</span><br><span class="line">      return y</span><br><span class="line">def f  (   a ) :</span><br><span class="line">  return      37+-+a[42-x :  y**3]</span><br></pre></td></tr></table></figure><p>经过yapf格式化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = &#123;&apos;a&apos;: 37, &apos;b&apos;: 42, &apos;c&apos;: 927&#125;</span><br><span class="line"></span><br><span class="line">y = &apos;hello &apos; &apos;world&apos;</span><br><span class="line">z = &apos;hello &apos; + &apos;world&apos;</span><br><span class="line">a = &apos;hello &#123;&#125;&apos;.format(&apos;world&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class foo(object):</span><br><span class="line">    def f(self):</span><br><span class="line">        return 37 * -+2</span><br><span class="line"></span><br><span class="line">    def g(self, x, y=42):</span><br><span class="line">        return y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(a):</span><br><span class="line">    return 37 + -+a[42 - x:y**3]</span><br></pre></td></tr></table></figure><h3 id="作为模块调用举例"><a href="#作为模块调用举例" class="headerlink" title="作为模块调用举例"></a><a href="https://github.com/google/yapf#id9" target="_blank" rel="noopener">作为模块调用举例</a></h3><h3 id="yapf的可配置项-Knobs"><a href="#yapf的可配置项-Knobs" class="headerlink" title="yapf的可配置项(Knobs)"></a>yapf的可配置项(Knobs)</h3><p>翻译成开关也可以</p><p><a href="https://github.com/google/yapf#id10" target="_blank" rel="noopener">https://github.com/google/yapf#id10</a></p><h3 id="使用yapf过程中可能会遇到的问题"><a href="#使用yapf过程中可能会遇到的问题" class="headerlink" title="使用yapf过程中可能会遇到的问题?"></a>使用yapf过程中可能会遇到的问题?</h3><p>官方举了两个例子：</p><p><a href="https://github.com/google/yapf#id12" target="_blank" rel="noopener">Why does YAPF destroy my awesome formatting?</a></p><p><a href="https://github.com/google/yapf#id13" target="_blank" rel="noopener">Why Not Improve Existing Tools?</a></p><p><a href="https://github.com/google/yapf#id14" target="_blank" rel="noopener">Can I Use YAPF In My Program?</a></p><h3 id="阔怕的细节-gory-details-："><a href="#阔怕的细节-gory-details-：" class="headerlink" title="阔怕的细节(gory details)："></a>阔怕的细节(gory details)：</h3><p>看了一下看不懂，可怕，大致意思是用一个加权树算法来计算是否将一行分开，又是否合并两行，我把英文的贴到这，以后再看；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Algorithm Design</span><br><span class="line">The main data structure in YAPF is the UnwrappedLine object. It holds a list of FormatTokens,</span><br><span class="line"></span><br><span class="line">that we would want to place on a single line if there were no column limit. An exception being</span><br><span class="line"></span><br><span class="line">a comment in the middle of an expression statement will force the line to be formatted on more</span><br><span class="line"></span><br><span class="line">than one line. The formatter works on one UnwrappedLine object at a time.</span><br><span class="line"></span><br><span class="line">An UnwrappedLine typically won&apos;t affect the formatting of lines before or after it. There is a</span><br><span class="line"></span><br><span class="line">part of the algorithm that may join two or more UnwrappedLines into one line. For instance, an</span><br><span class="line"></span><br><span class="line">if-then statement with a short body can be placed on a single line:</span><br><span class="line"></span><br><span class="line">if a == 42: continue</span><br><span class="line"></span><br><span class="line">YAPF&apos;s formatting algorithm creates a weighted tree that acts as the solution space for the algorithm.</span><br><span class="line"></span><br><span class="line">Each node in the tree represents the result of a formatting decision --- i.e., whether to split</span><br><span class="line"></span><br><span class="line">or not to split before a token. Each formatting decision has a cost associated with it. Therefore,</span><br><span class="line"></span><br><span class="line">the cost is realized on the edge between two nodes. (In reality, the weighted tree doesn&apos;t have </span><br><span class="line"></span><br><span class="line">separate edge objects, so the cost resides on the nodes themselves.)</span><br><span class="line"></span><br><span class="line">For example, take the following Python code snippet. For the sake of this example, assume that</span><br><span class="line"></span><br><span class="line">line (1) violates the column limit restriction and needs to be reformatted.</span><br><span class="line"></span><br><span class="line">def xxxxxxxxxxx(aaaaaaaaaaaa, bbbbbbbbb, cccccccc, dddddddd, eeeeee):  # 1</span><br><span class="line">    pass                                                               # 2</span><br><span class="line"></span><br><span class="line">For line (1), the algorithm will build a tree where each node (a FormattingDecisionState object)</span><br><span class="line"></span><br><span class="line">is the state of the line at that token given the decision to split before the token or not.</span><br><span class="line"></span><br><span class="line">Note: the FormatDecisionState objects are copied by value so each node in the graph is unique </span><br><span class="line"></span><br><span class="line">and a change in one doesn&apos;t affect other nodes.</span><br><span class="line"></span><br><span class="line">Heuristics are used to determine the costs of splitting or not splitting. Because a node holds </span><br><span class="line"></span><br><span class="line">the state of the tree up to a token&apos;s insertion, it can easily determine if a splitting decision</span><br><span class="line"></span><br><span class="line">will violate one of the style requirements. For instance, the heuristic is able to apply an extra</span><br><span class="line"></span><br><span class="line">penalty to the edge when not splitting between the previous token and the one being added.</span><br><span class="line"></span><br><span class="line">There are some instances where we will never want to split the line, because doing so will always</span><br><span class="line"></span><br><span class="line">be detrimental (i.e., it will require a backslash-newline, which is very rarely desirable). </span><br><span class="line"></span><br><span class="line">For line (1), we will never want to split the first three tokens: def, xxxxxxxxxxx, and (. Nor will</span><br><span class="line"></span><br><span class="line">we want to split between the ) and the : at the end. These regions are said to be &quot;unbreakable.&quot;</span><br><span class="line"></span><br><span class="line">This is reflected in the tree by there not being a &quot;split&quot; decision (left hand branch) within </span><br><span class="line"></span><br><span class="line">the unbreakable region.</span><br><span class="line"></span><br><span class="line">Now that we have the tree, we determine what the &quot;best&quot; formatting is by finding the path through</span><br><span class="line"></span><br><span class="line">the tree with the lowest cost.</span><br><span class="line"></span><br><span class="line">And that&apos;s it!</span><br></pre></td></tr></table></figure><h2 id="autopep8"><a href="#autopep8" class="headerlink" title="autopep8"></a>autopep8</h2><p>link：</p><p><a href="https://pypi.org/project/autopep8/0.8/" target="_blank" rel="noopener">https://pypi.org/project/autopep8/0.8/</a></p><p><a href="https://github.com/hhatto/autopep8" target="_blank" rel="noopener">https://github.com/hhatto/autopep8</a></p><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Autopep8是一个将Python代码<strong>自动排版为PEP8风格的小工具</strong>。它使用pep8工具来决定代码中的哪部分需要被排版。Autopep8可以修复大部分pep8工具中报告的排版问题。</p><h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install autopep8</span><br></pre></td></tr></table></figure><p>依赖于 <a href="https://github.com/PyCQA/pycodestyle" target="_blank" rel="noopener">pycodestyle</a></p><h3 id="autopep8可以修复哪些状态码"><a href="#autopep8可以修复哪些状态码" class="headerlink" title="autopep8可以修复哪些状态码"></a>autopep8可以修复哪些状态码</h3><p>(我管这些错误提示统称叫状态码)</p><h4 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h4><p>autopep8可以修复一些pycodestyle的一些错误提示，具体的可以修复的状态码列表如下：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-379138054a9979d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/7770956-2c836aaddce3dfe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>pycodestyle的错误格式提示码：<br><a href="https://pycodestyle.readthedocs.io/en/latest/intro.html#error-codes" target="_blank" rel="noopener">https://pycodestyle.readthedocs.io/en/latest/intro.html#error-codes</a></p><h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><p>autopep8还可以修复一些不在pycodestyle格式范围内的错误：</p><ul><li>纠正弃用的以及非惯用的python代码（通过 lib2to3）。这会让python 2.6 以及 python 2.7 的代码更加与 python3 兼容。（如果 W690 是enable的，这一项修复会被触发）</li><li>标准化具有多种行结束符的文件。</li><li>在类申明和它的第一个方法申明中间加一个空行。（由 E309 enable）</li><li>在类文档和它的第一个方法申明中间加一个空行。（由 E301 enable）</li><li>移除方法申明和它的文档之间的空行。 （由 E303 enable ）</li></ul><h4 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h4><p>autopep8也会忽略一些pycodestyle检查出来的状态码：</p><p>E112( expected an indented block)/E113(unexpected indentation)<br>用于非注释的E112 / E113是破坏语法规则的不良缩进的报告。 这些不应该被修改。</p><p>E265 block comment should start with ‘# ‘<br>如果注释看起来像代码，则忽略注释哈希后的间距。 autopep8避免修改这些因为它们不是真正的注释。 如果您真的想摆脱pycodestyle警告，请考虑删除已注释掉的代码。 （这可以通过根除自动化。）<br>大致意思应该是说，E265报的错误是注释的一段代码，所以不把这段代码格式化；</p><h3 id="autopep8使用"><a href="#autopep8使用" class="headerlink" title="autopep8使用"></a>autopep8使用</h3><p>autopep8默认不修复E711/E712,因为怕我们自己重写了默认的<strong>eq</strong>方法,即把x == None 修改成 x is None<br>也不修改所有的W6警告（一些旧的书写格式告警）：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-7615f92f05a28958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>–aggressive/-a选项可以提高代码修改错误码的等级，E712报的错误，就是在–aggressive等级是2 的时候修复（就是，x == True could be changed to either x or x is True, but autopep8 chooses the former）<br>–aggressive选项还会删除代码中的行末空格，要是想更加规范代码中的文档注释，可以使用 <a href="https://github.com/myint/docformatter" target="_blank" rel="noopener">docformatter</a></p><p>可是你知道吗，我在此有一问，aggressive一共有几个等级？这文档也没有说明，或许只能从代码里找答案了…..</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>一段不规范的代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import math, sys;</span><br><span class="line"></span><br><span class="line">def example1():</span><br><span class="line">    ####This is a long comment. This should be wrapped to fit within 72 characters.</span><br><span class="line">    some_tuple=(   1,2, 3,&apos;a&apos;  );</span><br><span class="line">    some_variable=&#123;&apos;long&apos;:&apos;Long code lines should be wrapped within 79 characters.&apos;,</span><br><span class="line">    &apos;other&apos;:[math.pi, 100,200,300,9876543210,&apos;This is a long string that goes on&apos;],</span><br><span class="line">    &apos;more&apos;:&#123;&apos;inner&apos;:&apos;This whole logical line should be wrapped.&apos;,some_tuple:[1,</span><br><span class="line">    20,300,40000,500000000,60000000000000000]&#125;&#125;</span><br><span class="line">    return (some_tuple, some_variable)</span><br><span class="line">def example2(): return &#123;&apos;has_key() is deprecated&apos;:True&#125;.has_key(&#123;&apos;f&apos;:2&#125;.has_key(&apos;&apos;));</span><br><span class="line">class Example3(   object ):</span><br><span class="line">    def __init__    ( self, bar ):</span><br><span class="line">     #Comments should have a space after the hash.</span><br><span class="line">     if bar : bar+=1;  bar=bar* bar   ; return bar</span><br><span class="line">     else:</span><br><span class="line">                    some_string = &quot;&quot;&quot;</span><br><span class="line">                       Indentation in multiline strings should not be touched.</span><br><span class="line">Only actual code should be reindented.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">                    return (sys.path, some_string)</span><br></pre></td></tr></table></figure><p></p><p>autopep8格式化命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autopep8 --in-place --aggressive --aggressive &lt;filename&gt;</span><br><span class="line">简写：</span><br><span class="line">autopep8 -i -a -a &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>经过autopep8格式化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def example1():</span><br><span class="line">    # This is a long comment. This should be wrapped to fit within 72</span><br><span class="line">    # characters.</span><br><span class="line">    some_tuple = (1, 2, 3, &apos;a&apos;)</span><br><span class="line">    some_variable = &#123;</span><br><span class="line">        &apos;long&apos;: &apos;Long code lines should be wrapped within 79 characters.&apos;,</span><br><span class="line">        &apos;other&apos;: [</span><br><span class="line">            math.pi,</span><br><span class="line">            100,</span><br><span class="line">            200,</span><br><span class="line">            300,</span><br><span class="line">            9876543210,</span><br><span class="line">            &apos;This is a long string that goes on&apos;],</span><br><span class="line">        &apos;more&apos;: &#123;</span><br><span class="line">            &apos;inner&apos;: &apos;This whole logical line should be wrapped.&apos;,</span><br><span class="line">            some_tuple: [</span><br><span class="line">                1,</span><br><span class="line">                20,</span><br><span class="line">                300,</span><br><span class="line">                40000,</span><br><span class="line">                500000000,</span><br><span class="line">                60000000000000000]&#125;&#125;</span><br><span class="line">    return (some_tuple, some_variable)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def example2(): return (&apos;&apos; in &#123;&apos;f&apos;: 2&#125;) in &#123;&apos;has_key() is deprecated&apos;: True&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Example3(object):</span><br><span class="line">    def __init__(self, bar):</span><br><span class="line">        # Comments should have a space after the hash.</span><br><span class="line">        if bar:</span><br><span class="line">            bar += 1</span><br><span class="line">            bar = bar * bar</span><br><span class="line">            return bar</span><br><span class="line">        else:</span><br><span class="line">            some_string = &quot;&quot;&quot;</span><br><span class="line">                       Indentation in multiline strings should not be touched.</span><br><span class="line">Only actual code should be reindented.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">            return (sys.path, some_string)</span><br></pre></td></tr></table></figure><p>其他常见命令行<br>指定autopep8只修改指定的状态码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autopep8 --select=E1,W1 &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>只修改已被弃用的代码功能（W6）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autopep8 --aggressive --select=W6 &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>想要看详细的修改过程，可以使用选项-v：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autopep8 -v &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="autopep8配置文件"><a href="#autopep8配置文件" class="headerlink" title="autopep8配置文件"></a>autopep8配置文件</h3><p>如果想把autopep8的选项放到配置文件中，把指定的选项修改到配置文件<br>autopep8默认识别的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux：$HOME/.config/.pycodestyle</span><br><span class="line">windows：~\.pycodestyle</span><br></pre></td></tr></table></figure><p>与其他的配置也兼容的文件：<br>setup.cfg, tox.ini, .pep8 and .flake8</p><p>在pep8, pycodestyle, flake8中配置格式举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pycodestyle]</span><br><span class="line">max_line_length = 120</span><br><span class="line">ignore = E501</span><br></pre></td></tr></table></figure><h3 id="使用autopep8自动化测试"><a href="#使用autopep8自动化测试" class="headerlink" title="使用autopep8自动化测试"></a>使用autopep8自动化测试</h3><p>可以写到项目的test/test_autopep8.py中，直接使用python test/test_autopep8.py来测试，也可以使用tox来测试，使用tox测试适用于测试是否适用多个python版本非常有用；</p><p>可以通过test / acid.py获得广谱测试。 此脚本针对Python代码运行autopep8，并检查代码修复的正确性和完整性。 它可以检查字节码是否保持相同。 test / acid_pypi.py使用acid.py来测试PyPI上最新发布的软件包。</p><blockquote><p>什么是noqa：</p></blockquote><blockquote><p>no quality assurance（没有质量保证）</p></blockquote><blockquote><p>Adding # noqa to a line indicates that the linter (a program that automatically checks code quality) should not check this line. Any warnings that code may have generated will be ignored.</p></blockquote><h2 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a>coverage</h2><p>link:</p><p><a href="https://coverage.readthedocs.io/en/v4.5.x/" target="_blank" rel="noopener">https://coverage.readthedocs.io/en/v4.5.x/</a></p><p><a href="https://pypi.org/project/coverage/" target="_blank" rel="noopener">https://pypi.org/project/coverage/</a></p><h3 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install coverage</span><br></pre></td></tr></table></figure><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run – Run a Python program and collect execution data.</span><br><span class="line">report – Report coverage results.</span><br><span class="line">html – Produce annotated HTML listings with coverage results.</span><br><span class="line">xml – Produce an XML report with coverage results.</span><br><span class="line">annotate – Annotate source files with coverage results.</span><br><span class="line">erase – Erase previously collected coverage data.</span><br><span class="line">combine – Combine together a number of data files.</span><br><span class="line">debug – Get diagnostic information.</span><br></pre></td></tr></table></figure><p>基本上就是跑一下覆盖率的测试然后把结果保存到html，xml等等</p><p>配置文件内容及格式：<a href="https://coverage.readthedocs.io/en/v4.5.x/config.html#config" target="_blank" rel="noopener">https://coverage.readthedocs.io/en/v4.5.x/config.html#config</a></p><h3 id="coverage-run"><a href="#coverage-run" class="headerlink" title="coverage run"></a>coverage run</h3><p>arg1与arg2是手动传入的参数<br>默认不指定任何参数时，是当前文件夹下所有的代码；<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ coverage run my_program.py arg1 arg2</span><br><span class="line">blah blah ..your program&apos;s output.. blah blah</span><br></pre></td></tr></table></figure><p></p><h4 id="使用过程中可能用到的选项"><a href="#使用过程中可能用到的选项" class="headerlink" title="使用过程中可能用到的选项"></a>使用过程中可能用到的选项</h4><ol><li>使用-m选项也可以从模块导入要测试的函数或者类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ coverage run -m packagename.modulename arg1 arg2</span><br><span class="line">blah blah ..your program&apos;s output.. blah blah</span><br></pre></td></tr></table></figure><ol start="2"><li>使用–source &lt;packages name/directories&gt;<blockquote><p>(&lt;packages name/directories&gt;使用逗号或换行符分隔)<br>使用source选项还可以使coverage.py报告未执行的文件，因为它可以在选项指定的包或目录中搜索尚未测试到的文件。这里所说的文件是指带有<strong>init</strong>.py可导入的模块</p></blockquote></li><li>–include<patterns><br>指定匹配的文件，patterns在此可使用正则,使用举例：/usr/*<br>如果source和include选项同时配置了，那么生效的是source选项；<br>也可以用在导出xml和html报告的输出命令中</patterns></li><li>–omit<patterns><br>指定要忽略的文件,patterns使用同上<br>也可以用在导出xml和html报告的输出命令中</patterns></li><li>–branch选项 <a href="https://coverage.readthedocs.io/en/v4.5.x/branch.html#branch" target="_blank" rel="noopener">https://coverage.readthedocs.io/en/v4.5.x/branch.html#branch</a></li><li>–concurrency<mode><br>multiprocessing, thread, greenlet, eventlet, or gevent<br>multiprocessing 不支持放在命令行</mode></li><li>–pylib<br>测试默认安装的包或模块</li><li>–rcfile=FILE<br>指定配置文件，在配置文件中可配置的项比命令行选项更丰富</li></ol><h3 id="coverage-warnnings"><a href="#coverage-warnnings" class="headerlink" title="coverage warnnings"></a>coverage warnnings</h3><p>During execution, coverage.py may warn you about conditions it detects that could affect the measurement process. The possible warnings include:</p><p><strong>“Trace function changed, measurement is likely wrong: XXX (trace-changed)”</strong></p><p>Coverage measurement depends on a Python setting called the trace function. Other Python code in your product</p><p>might change that function, which will disrupt coverage.py’s measurement. This warning indicates that has happened.</p><p>The XXX in the message is the new trace function value, which might provide a clue to the cause.</p><p><strong>“Module XXX has no Python source (module-not-python)”</strong></p><p>You asked coverage.py to measure module XXX, but once it was imported, it turned out not to have a corresponding .py file. Without a .py file,</p><p>coverage.py can’t report on missing lines.</p><p><strong>“Module XXX was never imported (module-not-imported)”</strong></p><p>You asked coverage.py to measure module XXX, but it was never imported by your program.</p><p><strong>“No data was collected (no-data-collected)”</strong></p><p>Coverage.py ran your program, but didn’t measure any lines as executed. This could be because you asked to measure only modules that never ran, or for other reasons.</p><p><strong>“Module XXX was previously imported, but not measured (module-not-measured)”</strong></p><p>You asked coverage.py to measure module XXX, but it had already been imported when coverage started. This meant coverage.py couldn’t monitor its execution.</p><p><strong>“–include is ignored because –source is set (include-ignored)”</strong></p><p>Both –include and –source were specified while running code. Both are meant to focus measurement on a particular part of your source code, so –include is ignored in favor of –source.</p><h4 id="配置这个warnning不可见"><a href="#配置这个warnning不可见" class="headerlink" title="配置这个warnning不可见"></a>配置这个warnning不可见</h4><p>Individual warnings can be disabled with the disable_warnings configuration setting. To silence “No data was collected,” add this to your .coveragerc file:</p><p>[run]<br>disable_warnings = no-data-collected</p><p>输出结果：<br>默认是存放在.coverage文件中，可通过环境变量COVERAGE_FILE指定<br>如果想要保存多次结果可使用-a选项，将执行结果追加在上次执行结果的后面；</p><h3 id="coverage-erase-清除结果"><a href="#coverage-erase-清除结果" class="headerlink" title="coverage erase 清除结果"></a>coverage erase 清除结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ coverage erase</span><br></pre></td></tr></table></figure><h3 id="coverage-combine-合并当前目录下的coverage结果"><a href="#coverage-combine-合并当前目录下的coverage结果" class="headerlink" title="coverage combine 合并当前目录下的coverage结果"></a>coverage combine 合并当前目录下的coverage结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coverage combine</span><br></pre></td></tr></table></figure><p>合并指定名称，指定位置的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ coverage combine data1.dat windows_data_files/</span><br></pre></td></tr></table></figure><p>如果不指定名称，将合并.coverage 和.coverage.xxx这种以.coverage为前缀的文件，举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.coverage.machine1</span><br><span class="line">.coverage.20120807T212300</span><br><span class="line">.coverage.last_good_run.ok</span><br></pre></td></tr></table></figure><p>更详细的功能参考：<a href="https://coverage.readthedocs.io/en/v4.5.x/cmd.html" target="_blank" rel="noopener">https://coverage.readthedocs.io/en/v4.5.x/cmd.html</a></p><h3 id="converage-report-输出报告"><a href="#converage-report-输出报告" class="headerlink" title="converage report 输出报告"></a>converage report 输出报告</h3><p>在输出报告时可能用到的选项：</p><p>–include/–omit 参考上文</p><p>-i/-ignore-errors</p><p>The -i or –ignore-errors switch tells coverage.py to ignore problems encountered trying to find source files to report on.</p><p>This can be useful if some files are missing, or if your Python execution is tricky enough that file names are synthesized without real source files.</p><p>–fail-under</p><p>If you provide a –fail-under value, the total percentage covered will be compared to that value. If it is less,</p><p>the command will exit with a status code of 2, indicating that the total coverage was less than your target.</p><p>This can be used as part of a pass/fail condition, for example in a continuous integration server. This option isn’t available for annotate.</p><p>-m shows the line numbers of missing statements, If you are using branch coverage, then branch statistics will be</p><p>reported in the Branch and BrPart (for Partial Branch) columns, the Missing column will detail the missed branches</p><p>–skip-covered<br>The –skip-covered switch will leave out any file with 100% coverage, letting you focus on the files that still need attention.</p><p>输出报告的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ coverage report</span><br><span class="line">Name                      Stmts   Miss  Cover</span><br><span class="line">---------------------------------------------</span><br><span class="line">my_program.py                20      4    80%</span><br><span class="line">my_module.py                 15      2    86%</span><br><span class="line">my_other_module.py           56      6    89%</span><br><span class="line">---------------------------------------------</span><br><span class="line">TOTAL                        91     12    87%</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ coverage report -m</span><br><span class="line">Name                      Stmts   Miss Branch BrPart  Cover   Missing</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">my_program.py                20      4     10      2    80%   33-35, 36-&gt;38, 39</span><br><span class="line">my_module.py                 15      2      3      0    86%   8, 12</span><br><span class="line">my_other_module.py           56      6      5      1    89%   17-23, 40-&gt;45</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">TOTAL                        91     12     18      3    87%</span><br></pre></td></tr></table></figure><h3 id="HTML-annotaion"><a href="#HTML-annotaion" class="headerlink" title="HTML annotaion"></a><a href="https://coverage.readthedocs.io/en/v4.5.x/cmd.html#html-annotation" target="_blank" rel="noopener">HTML annotaion</a></h3><p><a href="https://nedbatchelder.com/files/sample_coverage_html/index.html" target="_blank" rel="noopener">html报告样例</a></p><p>生成命令：</p><p>The -d argument specifies an output directory, defaulting to “htmlcov”:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ coverage html -d coverage_html</span><br></pre></td></tr></table></figure><p></p><h3 id="Text-annotaion"><a href="#Text-annotaion" class="headerlink" title="Text annotaion"></a><a href="https://coverage.readthedocs.io/en/v4.5.x/cmd.html#text-annotation" target="_blank" rel="noopener">Text annotaion</a></h3><h3 id="XML-reporting"><a href="#XML-reporting" class="headerlink" title="XML reporting"></a><a href="https://coverage.readthedocs.io/en/v4.5.x/cmd.html#xml-reporting" target="_blank" rel="noopener">XML reporting</a></h3><p>The xml command writes coverage data to a “coverage.xml” file in a format compatible with <a href="http://cobertura.github.io/cobertura/" target="_blank" rel="noopener">Cobertura</a>.</p><p>You can specify the name of the output file with the -o switch.</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a><a href="https://coverage.readthedocs.io/en/v4.5.x/cmd.html#diagnostics" target="_blank" rel="noopener">debug</a></h3><p>The debug command shows internal information to help diagnose problems. If you are reporting a bug about coverage.py, including the output of this command can often help:</p><p>命令行使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ coverage debug sys &gt; please_attach_to_bug_report.txt</span><br></pre></td></tr></table></figure><p>Three types of information are available:</p><p>config: show coverage’s configuration<br>sys: show system configuration,<br>data: show a summary of the collected coverage data</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="https://linux.cn/article-10059-1.html" target="_blank" rel="noopener">https://linux.cn/article-10059-1.html</a></p><p><a href="https://www.jianshu.com/p/e485c82dcff9" target="_blank" rel="noopener">https://www.jianshu.com/p/e485c82dcff9</a></p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> pep8 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法整理</title>
      <link href="/archives/5124f222.html"/>
      <url>/archives/5124f222.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 27 2019 13:37:43 GMT+0800 (GMT+08:00) --><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>从第一个元素开始，跟他下一个元素比较，如果自己比较大，就跟相邻元素换一下，如果隔壁元素比较大，就不换了，继续比较隔壁元素和他的下一个元素的大小，遍历一遍就可以把列表中最大的值放在队尾，然后开始第二次遍历，知道n-1遍历，所有元素归位；</p><p>图示：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-42d0a30d5520d0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BubbleSort.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def BubbleSort(nums):</span><br><span class="line">    if len(nums) &gt;1:</span><br><span class="line">        for i in range(0, len(nums)):</span><br><span class="line">            for j in range(0, len(nums)-i-1):</span><br><span class="line">                if nums[j] &gt; nums[j+1]:</span><br><span class="line">                    nums[j+1], nums[j] = nums[j], nums[j+1]</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最好的情况下是列表本来就是有序的虽然不用交换，但是遍历的次数依然不会少，依然是O(n^2)，最坏的情况下，每次都要交换；</p><p>交换操作是非常昂贵的，冒泡排序法每次都是一小步一小步的，交换很多次，所以冒泡排序法是所有排序方法中最低效的方法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><p>冒泡排序的改进版，遍历一次就找到最大值，然后交换一次，不是每次比较都交换，第二次遍历就找到第二大的数字，并把它放到正确的位置<br>图示：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-2bd996b076b37244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="selectionSort.png"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def SelectionSort(nums):</span><br><span class="line">    length = len(nums)</span><br><span class="line">    for i in range(0, length):</span><br><span class="line">        index = 0</span><br><span class="line">        for j in range(0, length-i):</span><br><span class="line">            if nums[index] &lt; nums[j]:</span><br><span class="line">                index = j</span><br><span class="line">        nums[index],nums[length-i-1] = nums[length-i-1], nums[index]</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>选择排序和冒泡排序的循环遍历次数是一样的，但是交换次数明显少于冒泡排序，所以选择排序相比较于冒泡排序，执行更快一点；<br>最佳的情况下是列表原本就是有序列表，依然遍历O(n^2)次数，但是没有交换操作，这个也是可以优化的，当第一次发现列表是有序的时候就可以退出；</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>以第一个元素为例，对比比第一个元素大的，就插入到其左边，比他大就插入到右边<br>图示：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-0491bc2310105e2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InsertSort.png"><br>具体的排序过程插入操作一个元素的时候如下图，移动其他元素给目标元素空出位置，移位操作大概需要交换操作的三分之一的时间；<br><img src="https://upload-images.jianshu.io/upload_images/7770956-d2005472c731a3c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def SelectSort(a):</span><br><span class="line">    for i in range(len(a)):</span><br><span class="line">        min_index = i</span><br><span class="line">        for j in range(i, len(a)):</span><br><span class="line">            if a[min_index] &lt; a[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        a[min_index], a[i] = a[i], a[min_index]</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最好的情况下是列表本来就是有序的，时间复杂度是O(n)<br>最差的情况下是需要比较n-1个整数的总和，时间复杂度是O(n^2),算法</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>递减递增排序， 根据增量i，循环列表将i的倍数的项拿出来组成子列表，对子列表进行排序，当增量i为1时，排序操作就是插入排序，当增量不为1时，相比较来说，希尔排序移位的次数小于插入排序<br>图解：增量i为3<br><img src="https://upload-images.jianshu.io/upload_images/7770956-1e3f9055f0b5180f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shellsort.png"></p><p>每个子列表排序：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-4e4b8ab0deb80603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shellsort2.png"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def ShellSort(a):</span><br><span class="line">    h = 1</span><br><span class="line">    while(h &lt; len(a)/3):</span><br><span class="line">        h = 3*h +1</span><br><span class="line">    print(&quot;h: %d&quot; % h)</span><br><span class="line">    while h &gt;=1:</span><br><span class="line">        for i in range(len(a)):</span><br><span class="line">            j = i</span><br><span class="line">            while j in range(1, i+1) and a[j] &lt; a[j-h]:</span><br><span class="line">                a[j], a[j-h] = a[j-h], a[j]</span><br><span class="line">                j -=h</span><br><span class="line">        h = h//3</span><br></pre></td></tr></table></figure><p>关于h为什么使用递增序列（截图来自算法第四版）：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-5169c93bd31c48f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>希尔排序也可以用在大型数组，对于任意排序（不一定是随机的）的数组表现的也很好，相比于选择排序和插入排序，数组越大，希尔排序的优势越明显，使用sortcompare比较其性能，希尔排序能够解决一些初级算法无能为力的问题，这个例子也是说明了：通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一</p><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>乍一看，你可能认为希尔排序不会比插入排序更好，因为它最后一步执行了完整的插入排 序。 然而，结果是，该最终插入排序不需要进行非常多的比较（或移位），因为如上所述， 该列表已经被较早的增量插入排序预排序。 换句话说，每个遍历产生比前一个“更有序”的列 表。 这使得最终遍历非常有效。</p><p>希尔排序的时间复杂度倾向于落在O(n)和O(n^2)之间的某处，基于以上所描述的行为。对于 Listing 5中显示的增量，性能为 O(n^2) 。<br>通过改变增量，例如使用 2^k-1（1,3,7,15,31等等） ，希尔排序可以在 O(n )处执行。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用分而治之策略，属于一种递归算法，当列表有多项时，我们对列表递归分割操作，直到拆分成最小的单位，每个列表只有一项，然后再比较排序，排序完后向上递归合并，直到合并成完整列表。<br>当列表为空或列表大小为1时，不需要排序。<br>列表大小是奇数或者偶数不影响排序，就相差一个元素。</p><p>第一步：元素拆分<br><img src="https://upload-images.jianshu.io/upload_images/7770956-0dfa0762735bfba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>第二步：排序合并<br><img src="https://upload-images.jianshu.io/upload_images/7770956-27207d9b79be8f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mergesort2.png"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>自顶向下的归并排序<br>实现1<br>这种写法，算是对于原地的写法吧，但是其中用到了数组的分片，我觉得也是需要额外的空间的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def mergeSort(nums):</span><br><span class="line">    import pdb;pdb.set_trace()</span><br><span class="line">    print(&apos;splitting&apos;, nums)</span><br><span class="line">    if len(nums) &gt; 1:</span><br><span class="line">        mid = len(nums) //2</span><br><span class="line">        left = nums[:mid]</span><br><span class="line">        right = nums[mid:]</span><br><span class="line">        </span><br><span class="line">        mergeSort(left)</span><br><span class="line">        mergeSort(right)</span><br><span class="line"></span><br><span class="line">        i = 0</span><br><span class="line">        j = 0</span><br><span class="line">        k = 0</span><br><span class="line">        #下边这段while是主要交换数据的，举例：</span><br><span class="line">        #left = 26, 54 right=17, 93, nums=[54, 26, 93 ,17]</span><br><span class="line">        #经过下边这段while会在 nums = [17, 26, 54, 17]的时候跳出循环，因为最后一个数字是还没写上的</span><br><span class="line">        #所以需要下边两个循环，将最后一个数字补上。。。递归真的绕晕</span><br><span class="line">        while i &lt; len(left) and j &lt; len(right):</span><br><span class="line">            if left[i] &lt; right[j]:</span><br><span class="line">                nums[k] = left[i]</span><br><span class="line">                i += 1</span><br><span class="line">            else:</span><br><span class="line">                nums[k] = right[j]</span><br><span class="line">                j +=1</span><br><span class="line">            k +=1</span><br><span class="line">        print(&apos;1i: %d, j: %d, k: %d&apos; %(i, j, k))</span><br><span class="line"></span><br><span class="line">        while i &lt; len(left):</span><br><span class="line">            nums[k] = left[i]</span><br><span class="line">            i += 1</span><br><span class="line">            k += 1</span><br><span class="line">        print(&apos;2i: %d, j: %d, k: %d&apos; %(i, j, k))</span><br><span class="line">        while j &lt; len(right):</span><br><span class="line">            nums[k] = right[j]</span><br><span class="line">            j +=1</span><br><span class="line">            k +=2</span><br><span class="line">        print(&apos;3i: %d, j: %d, k: %d&apos; %(i, j, k))</span><br><span class="line">    print(&quot;Merging&quot;, nums)</span><br><span class="line"></span><br><span class="line">nums=[54, 26, 93, 17, 77, 31, 44, 55, 20]</span><br><span class="line">mergeSort(nums)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure><p>实现2<br>这种写法，多出了一个字典专门用来存储其中的数组变量的；<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">def LocalSort(a, low, mid, high):</span><br><span class="line">    i = low</span><br><span class="line">    j = mid +1</span><br><span class="line">    aux = &#123;&#125;</span><br><span class="line">    for k in range(low, high+1):</span><br><span class="line">        aux[k] = a[k]</span><br><span class="line"></span><br><span class="line">    k = low</span><br><span class="line">    while k in range(low, high+1):</span><br><span class="line">        if i &gt; mid:</span><br><span class="line">            a[k] = aux[j]</span><br><span class="line">            j +=1</span><br><span class="line">            print(&quot;i: %d&quot; %i)</span><br><span class="line">            print(&quot;a: &quot;, a[:k+1])</span><br><span class="line">        elif j &gt; high:</span><br><span class="line">            a[k] = aux[i]</span><br><span class="line">            i +=1</span><br><span class="line">            print(&quot;j: %d&quot; %j)</span><br><span class="line">            print(&quot;a: &quot;, a[:k+1])</span><br><span class="line">        elif aux[j] &lt; aux[i]:</span><br><span class="line">            a[k] = aux[j]</span><br><span class="line">            j +=1</span><br><span class="line">            print(&quot;j: %d&quot; %j)</span><br><span class="line">            print(&quot;a: &quot;, a[:k+1])</span><br><span class="line">        else:</span><br><span class="line">            a[k] = aux[i]</span><br><span class="line">            i +=1</span><br><span class="line">            print(&quot;i: %d&quot; %i)</span><br><span class="line">            print(&quot;a: &quot;, a[:k+1])</span><br><span class="line">        k +=1</span><br><span class="line"></span><br><span class="line">def MergeSort2(a, low, high):</span><br><span class="line">    if high &lt;= low:</span><br><span class="line">        return</span><br><span class="line">    mid = low + (high-low)//2</span><br><span class="line">    print(&quot;low: %d, mid: %d, high: %d&quot;%(low, mid, high))</span><br><span class="line">    MergeSort2(a, low, mid)</span><br><span class="line">    MergeSort2(a, mid+1, high)</span><br><span class="line">    print(&quot;a: &quot;, a[low:high+1])</span><br><span class="line">    LocalSort(a, low, mid, high)</span><br><span class="line"></span><br><span class="line">a = [8,4,9,1,2,5,0,19,33]</span><br><span class="line">length = len(a)</span><br><span class="line">MergeSort2(a, 0, length -1)</span><br></pre></td></tr></table></figure><p></p><p>自底向上的归并排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def MergeSortBU(a):</span><br><span class="line">    length = len(a)</span><br><span class="line">    aux = []</span><br><span class="line">    i = 1</span><br><span class="line">    while i &lt; length:</span><br><span class="line">        low = 0</span><br><span class="line">        while low &lt; length - i:</span><br><span class="line">            LocalSort(a, low, low+i-1, min(low+i+i-1, length-1))</span><br><span class="line">            low = low +i +i</span><br><span class="line">        i +=i</span><br><span class="line">LocalSort()函数参考上一段代码</span><br></pre></td></tr></table></figure><p>自底向上这个算法轨迹：<br>因为我没看太懂这个算法，留着这个图，以后再看再理解<br><img src="https://upload-images.jianshu.io/upload_images/7770956-f8501bffd71cdbd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(nlogn), 拆分列表的时候需要O(logn),合并的时候是需要循环整个列表的需要O(n)，所以总的时间复杂度是O(nlogn),代码1中的切片的时间复杂度O(k)可以后续优化，而且因为是切片操作，切出来的列表需要占用额外的空间，当列表很大时，这里也是一个问题.在代码2和代码3中就不存在这个问题啦，啊哈哈哈~</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h3><p>选择列表的一个数作为基准值base，设置指针，一个从左到右left，一个从右到左的right，当left的值大于时，left停下，当right小于base时停下，交换left和right，<br>最终知道left和right相遇，对比base的值，base和其中比base小的值交换，这样循环一遍基准值base一定归位，左边全是比base小的，右边全是比base大的，下一次再循环基准值的左半边，和基准值的右半边；<br>当列表长度小于1时，认为他是有序的，不需要排序</p><p>图示：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-026a1379222f2f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="quicksort.png"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def quickSort(nums):</span><br><span class="line">    quickSortHelper(nums, 0, len(nums)-1)</span><br><span class="line"></span><br><span class="line">def quickSortHelper(nums, first, last):</span><br><span class="line">    #M = 15   当数组元素个数小于15时，改用插入排序，因为插入排序在这时更快</span><br><span class="line">    #if last &lt;= (first + M):</span><br><span class="line">    #    InserSort(nums)</span><br><span class="line">    #    return</span><br><span class="line">    if last &lt;= first:</span><br><span class="line">        return</span><br><span class="line">    split = partition(nums, first, last)</span><br><span class="line">    quickSortHelper(nums, first, split - 1)</span><br><span class="line">    quickSortHelper(nums, split+1, last)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def partition(nums, first, last):</span><br><span class="line">    #import pdb;pdb.set_trace()</span><br><span class="line">    base = nums[first]</span><br><span class="line">    print(&apos;base: %d&apos; % base)</span><br><span class="line">    left = first + 1</span><br><span class="line">    right = last</span><br><span class="line">    done = False</span><br><span class="line">    while not done:</span><br><span class="line">        while left &lt;= right and nums[left] &lt;= base:</span><br><span class="line">            left +=1</span><br><span class="line">        while right &gt;= left and nums[right] &gt;= base:</span><br><span class="line">            right -=1</span><br><span class="line">        if left &gt; right:</span><br><span class="line">            done = True</span><br><span class="line">        else:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]  ##左边数字大，右边数字小，两种情况</span><br><span class="line">    nums[right], nums[first] = nums[first], nums[right]  #为什么是right, 因为left还是比base大，但是right是第一个比base小的数</span><br><span class="line">    print(&apos;nums&apos;, nums)</span><br><span class="line">    return right</span><br><span class="line">    </span><br><span class="line">nums = [54,26,93,17,77,31,44,55,20]</span><br><span class="line">quickSort(nums)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><ol><li>对于小数组，快速排序和插入排序对比，还是插入排序更快，多小算小呢，5-15之间，代码修改在上边注释中可以看到，当数组长度小于常数15时，会调用插入排序算法</li></ol><ol start="2"><li>在实际应用中可能排序的数组中存在着大量重复的元素，有很多重复的元素对于快速排序来说是有优化的空间的：</li></ol><p>三项切分的快速排序算法代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def Quick3way(a, low, high):</span><br><span class="line">    if high &lt;= low:</span><br><span class="line">        return</span><br><span class="line">    lt = low </span><br><span class="line">    i = low +1</span><br><span class="line">    gt = high</span><br><span class="line">    base = a[low]</span><br><span class="line">    while i &lt;= gt:</span><br><span class="line">        if a[i] &lt; base:</span><br><span class="line">            a[i], a[lt] = a[lt], a[i]</span><br><span class="line">            i +=1</span><br><span class="line">            lt +=1</span><br><span class="line">        elif a[i] &gt; base:</span><br><span class="line">            a[i], a[gt] = a[gt], a[i]</span><br><span class="line">            gt -=1</span><br><span class="line">        else:</span><br><span class="line">            i+=1</span><br><span class="line">    Quick3way(a, low, lt-1)</span><br><span class="line">    Quick3way(a, gt +1, high)</span><br></pre></td></tr></table></figure><p></p><p>有点难理解,来点解释和图：<br><img src="https://upload-images.jianshu.io/upload_images/7770956-1984e9f9eefb4281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/7770956-93696c00057d481f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最好的情况下，第一个元素作为base，拆分列表就刚好从中间对半对半的拆开，时间复杂度是O(logn), 拆分完在遍历交换元素的时候，是要遍历整个列表的，需要时间复杂度O(n)<br>最差的情况下,列表就是有序的列表，第一个元素作为base，每次检查一遍发现自己是正确的元素，左半边是空的元素全在有半边，这时的时间复杂度O(n^2)</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>使用满二叉树构造出一个二叉堆，堆排序是使用最大堆，最小堆，来解决数据中删除最大或最小的元素，插入一个元素，做完这些操作后堆经过排序，队列仍是有序的，当数据量较多时，也可以解决从数据中查找第k大元素，在以上这些使用场景堆排序很占优势</p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def HeapSort(a):</span><br><span class="line">    length = len(a)//2  - 1</span><br><span class="line">    for i in range(length, -1, -1):</span><br><span class="line">        sink(a, i, len(a) -1)</span><br><span class="line">     </span><br><span class="line">    for j in range(len(a)-1, 0, -1):</span><br><span class="line">        a[0] ,a[j] = a[j], a[0]</span><br><span class="line">        sink(a, 0, j - 1)</span><br><span class="line"></span><br><span class="line">def sink(a, k, N):</span><br><span class="line">    j = 2*k</span><br><span class="line">    while j &lt;= N:</span><br><span class="line">        if j &lt; N and a[j] &lt; a[j+1]:</span><br><span class="line">            j +=1</span><br><span class="line">        elif a[k] &lt; a[j]:</span><br><span class="line">            a[k], a[j] = a[j], a[k]</span><br><span class="line">            k = j</span><br><span class="line">            print(&quot;a: &quot;, a)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>堆排序算法的时间复杂度是O(nlogn)</p><h2 id="如何比较两个算法："><a href="#如何比较两个算法：" class="headerlink" title="如何比较两个算法："></a>如何比较两个算法：</h2><ol><li>实现并调试</li><li>分析算法的基本性质</li><li>对其相对性能做出猜想</li><li>用实验验证猜想<br>待补充。。。</li></ol><h2 id="算法对比："><a href="#算法对比：" class="headerlink" title="算法对比："></a>算法对比：</h2><p><img src="https://upload-images.jianshu.io/upload_images/7770956-bb3a8996b2d3662d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ceph梳理</title>
      <link href="/archives/c7ad3fcb.html"/>
      <url>/archives/c7ad3fcb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 27 2019 13:37:43 GMT+0800 (GMT+08:00) --><h2 id="一、数据寻址过程"><a href="#一、数据寻址过程" class="headerlink" title="一、数据寻址过程"></a>一、数据寻址过程</h2><h3 id="1-file-gt-object"><a href="#1-file-gt-object" class="headerlink" title="1.file -&gt;object"></a>1.file -&gt;object</h3><p>将大小不统一的file 切成均匀的小块并给每个小块加标记，方便后续的处理<br>ino(inode number的缩写，意思是file的id) + non(object number的缩写，是这个file切分产生的序列号) = oid（object id）<br>举例：<br>ino = filename 这个file被切成了3个object，object的序号依次为0，1,2<br>最终oid的序号： filename0 filename1 filename2<br>期间要保证ino的唯一性，否则重复了，后边的映射就无法进行了。</p><h3 id="2-Object-gt-PG"><a href="#2-Object-gt-PG" class="headerlink" title="2. Object -&gt; PG"></a>2. Object -&gt; PG</h3><p>假设pg的总数为m个（m应该是2的整数幂），算法最终的目的是将多个object近似均匀的映射到pg中；<br>object映射到哪个pg？计算公式如下：<br>hash(oid) &amp; mask -&gt;pgid<br>算法字面解释：<br>ceph指定一个静态哈希函数，计算oid的哈希值，将oid映射成为一个近似均匀分布的伪随机值，将这个伪随机值与mask值按位相与，最终得到pg的序号（pgid）<br>什么这么算：<br>根据RADOS的设计，给定PG的总数为m（m应该为2的整数幂），则mask的值为m-1。因此，哈希值计算和按位与操作的整体结果事实上是从所有m个PG中近似均匀地随机选择一个。基于这一机制，当有大量object和大量PG时，RADOS能够保证object和PG之间的近似均匀映射。又因为object是由file切分而来，大部分object的size相同，因而，这一映射最终保证了，各个PG中存储的object的总数据量近似均匀。</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
