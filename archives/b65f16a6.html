<!-- build time:Thu Mar 19 2020 15:35:56 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="prometheus, exporter,"><link rel="alternate" href="/atom.xml" title="桃之夭夭" type="application/atom+xml"><meta name="description" content="简介服务的功能获取openstack集群中cinder,nova,neutron, swift,swift-account-usage中的关于虚机，云盘，网络，存储相关的数据整理发送给prometheus server代码地址github链接: https://github.com/CanonicalLtd/prometheus-openstack-exporter.git分支: master(和"><meta name="keywords" content="prometheus, exporter"><meta property="og:type" content="article"><meta property="og:title" content="prometheus-opensatck-exporter源码解析"><meta property="og:url" content="https://haoxiaoci.github.io/archives/b65f16a6.html"><meta property="og:site_name" content="桃之夭夭"><meta property="og:description" content="简介服务的功能获取openstack集群中cinder,nova,neutron, swift,swift-account-usage中的关于虚机，云盘，网络，存储相关的数据整理发送给prometheus server代码地址github链接: https://github.com/CanonicalLtd/prometheus-openstack-exporter.git分支: master(和"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-03-19T07:33:46.898Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="prometheus-opensatck-exporter源码解析"><meta name="twitter:description" content="简介服务的功能获取openstack集群中cinder,nova,neutron, swift,swift-account-usage中的关于虚机，云盘，网络，存储相关的数据整理发送给prometheus server代码地址github链接: https://github.com/CanonicalLtd/prometheus-openstack-exporter.git分支: master(和"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://haoxiaoci.github.io/archives/b65f16a6.html"><title>prometheus-opensatck-exporter源码解析 | 桃之夭夭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">桃之夭夭</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">自留地</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://haoxiaoci.github.io/archives/b65f16a6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="haoxiaoci"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="桃之夭夭"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">prometheus-opensatck-exporter源码解析</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-19T15:17:58+08:00">2020-03-19 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/archives/b65f16a6.html#comments" itemprop="discussionUrl"><span class="post-comments-count gitment-comments-count" data-xid="/archives/b65f16a6.html" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="服务的功能"><a href="#服务的功能" class="headerlink" title="服务的功能"></a>服务的功能</h3><p>获取openstack集群中cinder,nova,neutron, swift,swift-account-usage中的关于虚机，云盘，网络，存储相关的数据整理发送给prometheus server</p><h3 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h3><p>github链接: <a href="https://note.youdao.com/" target="_blank" rel="noopener">https://github.com/CanonicalLtd/prometheus-openstack-exporter.git</a></p><p>分支: master(和tag 0.1.4的版本一致)</p><h3 id="它是怎么工作的"><a href="#它是怎么工作的" class="headerlink" title="它是怎么工作的"></a>它是怎么工作的</h3><ol><li>prometheus server端周期性来exporter端抓取数据 (这里的周期是在prometheus server中用scrape_interval定义的)</li><li>我们的exporter服务启动后，会开启port的监听，一旦监听到有请求，会调用exporter里的一些列函数，将整理好的metrics返回给prometheus server，数据采集成功</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>在看源码之前，或者之中需要知道的prometheus_client的一些概念</p><h3 id="关于prometheus-client需要知道的这些"><a href="#关于prometheus-client需要知道的这些" class="headerlink" title="关于prometheus_client需要知道的这些"></a>关于prometheus_client需要知道的这些</h3><p>registry：就是一个监控项仓库，可以有很多个collector<br>collector：就是一个自定义的监控项收集器，一个collector中可以有很多个metrics<br>metrics: 监控项<br>metrics类型：count，gauge，summary，histogram</p><ul><li>count类型：计数器 特点：只增不减，可以是浮点型，不一定非要是整数</li><li>gauge类型：瞬时值 特点：随意增减，浮点整数</li><li>summary类型：存储了 quantile数据，针对于长尾效应设计的，可画出准确的正态分布图</li><li>histogram类型： 收集正态分布数据，通过划分bucket，但是只是计数，比较粗略，客户端性能开销跟count和gauge差不多，图的准确性不如summary高，可画出粗略一点的正态分布图</li></ul><p>其中 gauge、histogram、summary这三种metrics都没在这个exporter中出现，为了metrics类型完整（一家人就是要整整齐齐），所以把这三个也贴出来了；<br>写一个简单的collector举例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from prometheus_client import Counter, Gauge, Histogram, Summary, \</span><br><span class="line">    CollectorRegistry, generate_latest, start_http_server</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class TestCollector():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.registry = CollectorRegistry()</span><br><span class="line">        self.count_metric = Counter(&apos;counter_metric_name&apos;,</span><br><span class="line">                         &apos;A counter metirc decription test&apos;)</span><br><span class="line">        self.gauge_metric = Gauge(&apos;gauge_metric_name&apos;,</span><br><span class="line">                                  &apos;A gauge metric description test&apos;)</span><br><span class="line">        self.histogram_metric = Histogram(&apos;histogram_metric_name&apos;,</span><br><span class="line">                           &apos;A histogram description test&apos;,</span><br><span class="line">                           buckets=(-5, 0, 5))</span><br><span class="line">        self.summary_metric = Summary(&apos;summary_metric_name&apos;,</span><br><span class="line">                         &apos;A summary description test&apos;,</span><br><span class="line">                        [&apos;label1&apos;, &apos;label2&apos;])</span><br><span class="line"></span><br><span class="line">    def test(self):</span><br><span class="line">        self.count_metric.inc(1)</span><br><span class="line">        self.gauge_metric.set(random.random())</span><br><span class="line">        self.histogram_metric.observe(random.randint(-10, 10))</span><br><span class="line">        self.summary_metric.labels(&apos;a&apos;, &apos;b&apos;).observe(17)</span><br><span class="line"></span><br><span class="line">        return generate_latest(registry=self.registry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    collector = TestCollector()</span><br><span class="line">    start_http_server(8000)</span><br><span class="line">    while True:</span><br><span class="line">        collector.test()</span><br><span class="line">        time.sleep(2)</span><br></pre></td></tr></table></figure><p></p><p>获取到的metric如下，我省略掉了一些prometheus_client自带的变量<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">HELP</span> summary_metric_name <span class="type">A</span> summary description test</span><br><span class="line"># <span class="type">TYPE</span> summary_metric_name summary</span><br><span class="line">summary_metric_name_count&#123;label1=<span class="string">"a"</span>,label2=<span class="string">"b"</span>&#125; <span class="number">1678.0</span></span><br><span class="line">summary_metric_name_sum&#123;label1=<span class="string">"a"</span>,label2=<span class="string">"b"</span>&#125; <span class="number">28526.0</span></span><br><span class="line"># <span class="type">TYPE</span> summary_metric_name_created gauge</span><br><span class="line">summary_metric_name_created&#123;label1=<span class="string">"a"</span>,label2=<span class="string">"b"</span>&#125; <span class="number">1.584496763390804e</span>+<span class="number">09</span></span><br><span class="line"># <span class="type">HELP</span> gauge_metric_name <span class="type">A</span> gauge metric description test</span><br><span class="line"># <span class="type">TYPE</span> gauge_metric_name gauge</span><br><span class="line">gauge_metric_name <span class="number">0.8280131429442902</span></span><br><span class="line"># <span class="type">HELP</span> counter_metric_name_total <span class="type">A</span> counter metirc decription test</span><br><span class="line"># <span class="type">TYPE</span> counter_metric_name_total counter</span><br><span class="line">counter_metric_name_total <span class="number">1678.0</span></span><br><span class="line"># <span class="type">TYPE</span> counter_metric_name_created gauge</span><br><span class="line">counter_metric_name_created <span class="number">1.584496762311975e</span>+<span class="number">09</span></span><br><span class="line"># <span class="type">HELP</span> histogram_metric_name <span class="type">A</span> histogram description test</span><br><span class="line"># <span class="type">TYPE</span> histogram_metric_name histogram</span><br><span class="line">histogram_metric_name_bucket&#123;le=<span class="string">"-5.0"</span>&#125; <span class="number">457.0</span></span><br><span class="line">histogram_metric_name_bucket&#123;le=<span class="string">"0.0"</span>&#125; <span class="number">848.0</span></span><br><span class="line">histogram_metric_name_bucket&#123;le=<span class="string">"5.0"</span>&#125; <span class="number">1262.0</span></span><br><span class="line">histogram_metric_name_bucket&#123;le=<span class="string">"+Inf"</span>&#125; <span class="number">1678.0</span></span><br><span class="line">histogram_metric_name_count <span class="number">1678.0</span></span><br><span class="line">histogram_metric_name_sum <span class="number">327.0</span></span><br><span class="line"># <span class="type">TYPE</span> histogram_metric_name_created gauge</span><br><span class="line">histogram_metric_name_created <span class="number">1.584496762312121e</span>+<span class="number">09</span></span><br></pre></td></tr></table></figure><p></p><h3 id="代码层逻辑实现"><a href="#代码层逻辑实现" class="headerlink" title="代码层逻辑实现"></a>代码层逻辑实现</h3><p>好了，现在开始干正事，代码的逻辑是下边这样的：</p><ol><li>开启一个线程，周期性(这里的周期是配置文件中的cache_refresh_interval定义的)的在线程内<ol><li>通过环境变量获取到openstack的client()</li><li>使用openstack的组件client()获取我们想要的数据，并将数据缓存至本地的二进制文件中</li></ol></li><li>开启一个事件监听循环：<ol><li>当有请求 /metrics的时候，在/metrics路由下 将各个组件的collector监控数据组合到一起，返回给客户端</li><li>各个组件(nova,cinder,neutron,swift)的collector类从上边已经缓存的缓存文件中纷纷读取自己的数据，做处理，放到自己的registry里，再返回到metrics路由</li></ol></li></ol><h3 id="从程序入口开始"><a href="#从程序入口开始" class="headerlink" title="从程序入口开始"></a>从程序入口开始</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    parser = argparse.ArgumentParser(usage=__doc__,</span><br><span class="line">                                     description=&apos;Prometheus OpenStack exporter&apos;,</span><br><span class="line">                                     formatter_class=argparse.RawTextHelpFormatter)</span><br><span class="line">    parser.add_argument(&apos;config_file&apos;, nargs=&apos;?&apos;,</span><br><span class="line">                        help=&apos;Configuration file path&apos;,</span><br><span class="line">                        default=&apos;/etc/prometheus/prometheus-openstack-exporter.yaml&apos;,</span><br><span class="line">                        type=argparse.FileType(&apos;r&apos;))</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    # 设置log的level，然后把log写到本地，或将日志输出到流 sys.stderr，sys.stdout</span><br><span class="line">    log.setLevel(logging.DEBUG)</span><br><span class="line">    for logsock in (&apos;/dev/log&apos;, &apos;/var/run/syslog&apos;):</span><br><span class="line">        if path.exists(logsock):</span><br><span class="line">            log.addHandler(logging.handlers.SysLogHandler(address=logsock))</span><br><span class="line">    else:</span><br><span class="line">        log.addHandler(logging.StreamHandler())</span><br><span class="line">    # 加载下配置文件</span><br><span class="line">    config = yaml.safe_load(args.config_file.read())</span><br><span class="line">    numeric_log_level = getattr(logging, config.get(&apos;log_level&apos;, &apos;INFO&apos;).upper(), None)</span><br><span class="line">    if not isinstance(numeric_log_level, int):</span><br><span class="line">        raise ValueError(&apos;Invalid log level: %s&apos; % config.get(&apos;log_level&apos;))</span><br><span class="line">    log.setLevel(numeric_log_level)</span><br><span class="line"></span><br><span class="line">    # 开启获取集群数据的线程</span><br><span class="line">    data_gatherer = None</span><br><span class="line">    if data_gatherer_needed(config):</span><br><span class="line">        data_gatherer = DataGatherer()</span><br><span class="line">        data_gatherer.start()</span><br><span class="line"></span><br><span class="line">    #  开启HTTPServer监听    </span><br><span class="line">    server = ForkingHTTPServer((&apos;&apos;, config.get(&apos;listen_port&apos;)), handler)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure><p>1.先加载到配置文件，2.初始化记录log，3.开启数据收集（data_gatherer.start()），4.启动事件监听（server.serve_forever()）<br>接下来先从数据收集开始</p><h3 id="开启线程，收集集群数据-DataGatherer-Thread"><a href="#开启线程，收集集群数据-DataGatherer-Thread" class="headerlink" title="开启线程，收集集群数据  | DataGatherer(Thread)"></a>开启线程，收集集群数据 | DataGatherer(Thread)</h3><p>单独开启一个线程，周期性通过client端获取我们所想要的数据，重写Thread的run()方法来完成我们想要在线程中进行的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class DataGatherer(Thread):</span><br><span class="line">    def run():</span><br><span class="line">        prodstack = &#123;&#125;</span><br><span class="line">        while True:</span><br><span class="line">            # 假如 prodstack = &#123;&#125; 写下这，每次刷新数据的时候都会把他先置空，再复制，倒不如直接update一步到位</span><br><span class="line">            try:</span><br><span class="line">                # 在这里获取client, 并将各个client的处理好的数据，更新到prodstack里</span><br><span class="line">                keystone, nova, neutron, cinder = get_clients()</span><br><span class="line">                prodstack.update(self._get_keystone_info(keystone))  # 这些client会单独处理自己的数据</span><br><span class="line">               prodstack.update(self._get_neutron_info(neutron))</span><br><span class="line">               prodstack.update(self._get_nova_info(nova, cinder, prodstack))</span><br><span class="line">           except Exception:</span><br><span class="line">                # Ignore failures, we will try again after refresh_interval.</span><br><span class="line">                # Most of them are termporary ie. connectivity problmes</span><br><span class="line">                # To alert on stale cache use openstack_exporter_cache_age_seconds metric</span><br><span class="line">                log.critical(&quot;Error getting stats: &#123;&#125;&quot;.format(traceback.format_exc()))</span><br><span class="line">            else:</span><br><span class="line">                # 在本地的二进制文件中写入加密的获取到的client的数据，作为缓存</span><br><span class="line">                with open(self.cache_file + &apos;.new&apos;, &quot;wb+&quot;) as f:</span><br><span class="line">                    pickle.dump((prodstack, ), f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">                rename(self.cache_file + &apos;.new&apos;, self.cache_file)</span><br><span class="line">                log.debug(&quot;Done dumping stats to &#123;&#125;&quot;.format(self.cache_file))</span><br><span class="line">            self.duration = time() - start_time</span><br><span class="line">            sleep(self.refresh_interval)   #间隔多久再重新获取一次数据</span><br></pre></td></tr></table></figure><p>Q: 为什么要加缓存呢，实时获取数据不好吗？<br>A：实时获取数据对于监控来说当然更精确，但是因为我们的查询比较繁琐，在集群规模比较大的情况下，查询一次可能需要几分钟，频繁的调API去抓取或者多个exporter抓取集群数据，也可能会导致集群响应延迟更高，还会给集群造成负面影响。</p><h3 id="HTTPServer的框架-ForkingHTTPServer"><a href="#HTTPServer的框架-ForkingHTTPServer" class="headerlink" title="HTTPServer的框架 | ForkingHTTPServer(..)"></a>HTTPServer的框架 | ForkingHTTPServer(..)</h3><p>单独把起HTTPServer的框架摘（二声）出来， 起一个异步进程HTTPserver并监听， 相关的代码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class OpenstackExporterHandler(BaseHTTPRequestHandler):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        BaseHTTPRequestHandler.__init__(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def do_GET(self):</span><br><span class="line">        ......</span><br><span class="line">  </span><br><span class="line">              </span><br><span class="line">class ForkingHTTPServer(ForkingMixIn, HTTPServer):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handler(*args, **kwargs):    </span><br><span class="line">    OpenstackExporterHandler(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    .......</span><br><span class="line">    server = ForkingHTTPServer((&apos;&apos;, config.get(&apos;listen_port&apos;)), handler)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure><p>自己创建的ForkingHTTPServer：<br><strong>ForkingHTTPServer</strong>：这里的ForkingHTTPServer继承自HTTPServer和ForkingMixIn，主要作用，异步起个进程，监听socket；</p><p>引用的模块中的两个类，这俩类的功能：<br><strong>HTTPServer</strong>：继承自SocketServer.TCPServer, HTTPServer主要实现启动事件监听和address port的绑定，并将请求交于handler处理</p><p><strong>ForkingMIxIn</strong>是继承于SocketServer用来做异步处理的类，它重载了process_request()方法，当出现新请求时创建一个新的进程，把具体工作放到新的进程中执行.</p><p>再来看一下我们的处理请求的Handler类<br><strong>OpenstackExporterHandler</strong>：继承自BaseHTTPRequestHandler<br>OpenstackExporterHandler中定义do_GET来处理请求</p><p><strong>BaseHTTPRequestHandler</strong> 是http handler的基类，无法直接使用，需要定义请求处理函数，所以我们重写do_GET()函数处理请求</p><p><strong>关于server和handler的关系</strong></p><p>python http框架主要有server和handler组成，server主要是用于建立网络模型，例如利用epoll监听socket；handler用于处理各个就绪的socket，就是server是用来启动事件监听，handler是来处理事件的。</p><p>总结一下就是当执行到下面这段代码时：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server = ForkingHTTPServer((&apos;&apos;, config.get(&apos;listen_port&apos;)), handler)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p></p><p>开启一个事件循环监听，(如果address是本地的话，可以在本地看到绑定的address和port)，可以在本地看到并将开启一个新进程来处理接受到的请求;</p><h3 id="获取client-get-clients"><a href="#获取client-get-clients" class="headerlink" title="获取client | get_clients()"></a>获取client | get_clients()</h3><p>接着看在线程中是怎么获取client()的<br>从当前环境变量中获取需要的认证信息，然后获取各个openstack组件的client()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">def get_clients():</span><br><span class="line">    ks_version = int(env.get(&apos;OS_IDENTITY_API_VERSION&apos;, 2))</span><br><span class="line">    if ks_version == 2:</span><br><span class="line">        from keystoneclient.v2_0 import client as keystone_client</span><br><span class="line">        # Legacy v2 env vars 在v2版本里用到了这些环境变量</span><br><span class="line">        # OS_USERNAME OS_PASSWORD OS_TENANT_NAME OS_AUTH_URL OS_REGION_NAME   </span><br><span class="line">        ks_creds = get_creds_dict(&quot;username&quot;, &quot;password&quot;, &quot;tenant_name&quot;,  </span><br><span class="line">                          &quot;auth_url&quot;, &quot;region_name&quot;)</span><br><span class="line">        # ks_creds打印：&#123;&apos;username&apos;: &apos;admin&apos;, &apos;tenant_name&apos;: &apos;admin&apos;, &apos;password&apos;: &apos;admin&apos;, &apos;auth_url&apos;: &apos;http://192.168.1.106/identity/v3&apos;, &apos;region_name&apos;: &apos;RegionOne&apos;&#125;                  </span><br><span class="line">        cacert = maybe_get_cacert()</span><br><span class="line">        if cacert:</span><br><span class="line">            ks_creds[&quot;cacert&quot;] = cacert</span><br><span class="line">        nova_creds = [2] + get_creds_list(&quot;username&quot;, &quot;password&quot;, &quot;tenant_name&quot;,</span><br><span class="line">                                          &quot;auth_url&quot;)</span><br><span class="line">        cinder_creds = get_creds_list(&quot;username&quot;, &quot;password&quot;, &quot;tenant_name&quot;,</span><br><span class="line">                                      &quot;auth_url&quot;)</span><br><span class="line">        # nova_creds打印：[2, &apos;admin&apos;, &apos;admin&apos;, &apos;admin&apos;, &apos;http://192.168.1.106/identity/v3&apos;]</span><br><span class="line">        # cinder_creds打印：[&apos;admin&apos;, &apos;admin&apos;, &apos;admin&apos;, &apos;http://192.168.1.106/identity/v3&apos;]                              </span><br><span class="line">        keystone = keystone_client.Client(**ks_creds)</span><br><span class="line">        nova = nova_client.Client(*nova_creds, cacert=cacert)</span><br><span class="line">        neutron = neutron_client.Client(**ks_creds)</span><br><span class="line">        cinder = cinder_client.Client(*cinder_creds, cacert=cacert)</span><br><span class="line">        elif ks_version == 3:</span><br><span class="line">            from keystoneauth1.identity import v3</span><br><span class="line">            from keystoneauth1 import session</span><br><span class="line">            from keystoneclient.v3 import client</span><br><span class="line">            # 在v3版本里用到了这些环境变量</span><br><span class="line">            #  OS_USERNAME OS_PASSWORD OS_USER_DOMAIN_NAME OS_AUTH_URL      </span><br><span class="line">            #  OS_PROJECT_DOMAIN_NAME OS_PROJECT_DOMAIN_ID OS_PROJECT_ID OS_DOMAIN_NAME</span><br><span class="line">        ks_creds_domain = get_creds_dict(</span><br><span class="line">            &quot;username&quot;, &quot;password&quot;, &quot;user_domain_name&quot;, &quot;auth_url&quot;,</span><br><span class="line">            &quot;project_domain_name&quot;, &quot;project_name&quot;, &quot;project_domain_id&quot;, &quot;project_id&quot;)</span><br><span class="line"></span><br><span class="line">        #ks_creds_domain输出：&#123;&apos;username&apos;: &apos;admin&apos;, &apos;user_domain_name&apos;: &apos;default&apos;, &apos;password&apos;: &apos;admin&apos;, &apos;auth_url&apos;: &apos;http://192.168.1.106/identity/v3&apos;&#125;    </span><br><span class="line">        # Need non-domain creds to get full catalog</span><br><span class="line"></span><br><span class="line">        ks_creds_admin = get_creds_dict(</span><br><span class="line">            &quot;username&quot;, &quot;password&quot;, &quot;user_domain_name&quot;, &quot;auth_url&quot;,</span><br><span class="line">            &quot;project_domain_name&quot;, &quot;project_name&quot;, &quot;project_domain_id&quot;, &quot;project_id&quot;)</span><br><span class="line">        # ks_creds_admin输出： &#123;&apos;username&apos;: &apos;admin&apos;, &apos;user_domain_name&apos;: &apos;default&apos;, &apos;password&apos;: &apos;admin&apos;, &apos;auth_url&apos;: &apos;http://192.168.1.106/identity/v3&apos;&#125;    </span><br><span class="line"></span><br><span class="line">        auth_domain = v3.Password(**ks_creds_domain)</span><br><span class="line">        auth_admin = v3.Password(**ks_creds_admin)</span><br><span class="line">        # Need to pass in cacert separately</span><br><span class="line">        verify = maybe_get_cacert()</span><br><span class="line">        if verify is None:</span><br><span class="line">            verify = True</span><br><span class="line">        sess_domain = session.Session(auth=auth_domain, verify=verify)</span><br><span class="line">        sess_admin = session.Session(auth=auth_admin, verify=verify)</span><br><span class="line"></span><br><span class="line">        keystone = client.Client(session=sess_domain)</span><br><span class="line">        nova = nova_client.Client(2, session=sess_admin)</span><br><span class="line">        neutron = neutron_client.Client(session=sess_admin)</span><br><span class="line">        cinder = cinder_client.Client(session=sess_admin)</span><br></pre></td></tr></table></figure><p></p><p>一个openrc示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export OS_USERNAME=admin</span><br><span class="line">export OS_TENANT_NAME=admin</span><br><span class="line">export OS_PASSWORD=admin</span><br><span class="line">export OS_REGION_NAME=RegionOne</span><br><span class="line">export OS_AUTH_URL=http://192.168.1.106/identity/v3</span><br><span class="line">export OS_IDENTITY_API_VERSION=3</span><br><span class="line">export OS_USER_DOMAIN_ID=default</span><br><span class="line">export OS_USER_DOMAIN_NAME=default</span><br><span class="line">export OS_PROJECT_DOMAIN_ID=default</span><br><span class="line">export OS_PROJECT_NAME=admin</span><br></pre></td></tr></table></figure><p></p><h3 id="来看看handler怎么处理给客户端返回数据的-OpenstackExporterHandler"><a href="#来看看handler怎么处理给客户端返回数据的-OpenstackExporterHandler" class="headerlink" title="来看看handler怎么处理给客户端返回数据的 |OpenstackExporterHandler(..)"></a>来看看handler怎么处理给客户端返回数据的 |OpenstackExporterHandler(..)</h3><p>在OpenstackExporterHandler中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 在这把collector的和具体实现collector的类的映射关系放到了字典里</span><br><span class="line">COLLECTORS = &#123;</span><br><span class="line">    &apos;cinder&apos;: Cinder,</span><br><span class="line">    &apos;neutron&apos;: Neutron,</span><br><span class="line">    &apos;nova&apos;: Nova,</span><br><span class="line">    &apos;swift&apos;: Swift,</span><br><span class="line">    &apos;swift-account-usage&apos;: SwiftAccountUsage,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">DATA_GATHERER_USERS = [</span><br><span class="line">    &apos;cinder&apos;,</span><br><span class="line">    &apos;neutron&apos;,</span><br><span class="line">    &apos;nova&apos;,</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class OpenstackExporterHandler(BaseHTTPRequestHandler):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        BaseHTTPRequestHandler.__init__(self, *args, **kwargs)</span><br><span class="line">        </span><br><span class="line">    def do_GET(self):</span><br><span class="line">        url = urlparse.urlparse(self.path)</span><br><span class="line">        if url.path == &apos;/metrics&apos;:</span><br><span class="line">            try:</span><br><span class="line">                # collectors取配置文件enable_collectors和本地可获取的所有collector的交集，</span><br><span class="line">                collectors = [COLLECTORS[collector]() for collector in get_collectors(config.get(&apos;enabled_collectors&apos;))]</span><br><span class="line">                log.debug(&quot;Collecting stats..&quot;)</span><br><span class="line">                output = &apos;&apos;</span><br><span class="line">                # 通过collector的get_stats()获取单个collector整理好的自己registry</span><br><span class="line">                for collector in collectors:</span><br><span class="line">                output += collector.get_stats()</span><br><span class="line">                # </span><br><span class="line">                if data_gatherer:</span><br><span class="line">                    output += data_gatherer.get_stats()</span><br><span class="line"></span><br><span class="line">                self.send_response(200)</span><br><span class="line">                self.send_header(&apos;Content-Type&apos;, CONTENT_TYPE_LATEST)</span><br><span class="line">                self.end_headers()</span><br><span class="line">                self.wfile.write(output)</span><br><span class="line">            except Exception:</span><br><span class="line">                self.send_response(500)</span><br><span class="line">                self.end_headers()</span><br><span class="line">                self.wfile.write(traceback.format_exc())</span><br></pre></td></tr></table></figure><p>OpenstackExporterHandler集成自BaseHTTPRequestHandler，通过重写do_GET()函数，响应请求</p><p>self.wfile也是BaseHTTPRequestHandler里方法，用来写入应答信息</p><p>self.send_header(..), self.send_response(..) 这些都是BaseHTTPRequestHandler中的方法</p><h3 id="来看一个Collector是怎么收集数据的-Nova"><a href="#来看一个Collector是怎么收集数据的-Nova" class="headerlink" title="来看一个Collector是怎么收集数据的 | Nova()"></a>来看一个Collector是怎么收集数据的 | Nova()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Nova():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 创建一个Collector仓库</span><br><span class="line">        self.registry = CollectorRegistry()      </span><br><span class="line">        self.prodstack = &#123;&#125;</span><br><span class="line">        # 从我们之前创建的cache_file中读取数据</span><br><span class="line">        with open(config[&apos;cache_file&apos;], &apos;rb&apos;) as f:    </span><br><span class="line">            self.prodstack = pickle.load(f)[0]</span><br><span class="line">        self.hypervisors = self.prodstack[&apos;hypervisors&apos;]</span><br><span class="line">            .......</span><br><span class="line">            </span><br><span class="line">    def gen_hypervisor_stats(self):</span><br><span class="line">        # 注册监控项</span><br><span class="line">        vms = Gauge(&apos;hypervisor_running_vms&apos;, &apos;Number of running VMs&apos;, labels, registry=self.registry)</span><br><span class="line">        vcpus_total = Gauge(&apos;hypervisor_vcpus_total&apos;, &apos;Total number of vCPUs&apos;, labels, registry=self.registry)</span><br><span class="line">        ......</span><br><span class="line">        for h in self.hypervisors:</span><br><span class="line">            # 给监控项赋值</span><br><span class="line">            vms.labels(*label_values).set(squashnone(h[&apos;running_vms&apos;]))</span><br><span class="line">            vcpus_total.labels(*label_values).set(squashnone(h[&apos;vcpus&apos;]))</span><br><span class="line">        .....</span><br><span class="line">  </span><br><span class="line">    def get_stats(self):</span><br><span class="line">        log.debug(&quot;get_stats&quot;)</span><br><span class="line">        # 下面这些函数都是从缓存文件中获取数据，监控项注册并赋值</span><br><span class="line">        self.gen_hypervisor_stats()</span><br><span class="line">        self.gen_instance_stats()</span><br><span class="line">        self.gen_overcommit_stats()</span><br><span class="line">        self.gen_quota_stats()</span><br><span class="line">        # 将收集到的监控项都注册到自己仓库中，并返回</span><br><span class="line">        return generate_latest(self.registry)</span><br></pre></td></tr></table></figure><p>通过get_stats()返回registry<br>再来看一下DataGatherer的get_stats()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DataGatherer(Thread):</span><br><span class="line">    def get_stats(self):</span><br><span class="line">        registry = CollectorRegistry()</span><br><span class="line">        labels = [&apos;cloud&apos;]</span><br><span class="line">        # age 是最新的缓存文件存在的时间</span><br><span class="line">        age = Gauge(&apos;openstack_exporter_cache_age_seconds&apos;,</span><br><span class="line">                    &apos;Cache age in seconds. It can reset more frequently &apos;</span><br><span class="line">                    &apos;than scraping interval so we use Gauge&apos;,</span><br><span class="line">                    labels, registry=registry)</span><br><span class="line">        label_values = [config[&apos;cloud&apos;]]</span><br><span class="line">        age.labels(*label_values).set(time() - path.getmtime(self.cache_file))</span><br><span class="line">        </span><br><span class="line">        # duration 是重新获取一次数据client开始到返回结果的时间</span><br><span class="line">        duration = Gauge(&apos;openstack_exporter_cache_refresh_duration_seconds&apos;,</span><br><span class="line">                         &apos;Cache refresh duration in seconds.&apos;,</span><br><span class="line">                         labels, registry=registry)</span><br><span class="line">        duration.labels(*label_values).set(self.duration)</span><br><span class="line">        return generate_latest(registry)</span><br></pre></td></tr></table></figure><p></p><h3 id="所有的metrics列表"><a href="#所有的metrics列表" class="headerlink" title="所有的metrics列表"></a>所有的metrics列表</h3><p>待补充</p><h2 id="grafana-dashboard"><a href="#grafana-dashboard" class="headerlink" title="grafana-dashboard"></a>grafana-dashboard</h2><p>对应的dashboard都写好了：</p><p><a href="https://grafana.com/grafana/dashboards/7924/reviews" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/7924/reviews</a><br>无奈我没有swift，所以不show图了；</p><p>监控swift那块好像还是有点精彩的，我没有swift环境，<br>参考链接：</p><p>关于HTTPServer的：<a href="http://luodw.cc/2016/11/05/python-http/" target="_blank" rel="noopener">http://luodw.cc/2016/11/05/python-http/</a></p><p>metrics参考: <a href="https://segmentfault.com/a/1190000018372390" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018372390</a></p><p>metrics参考2: <a href="https://www.infoq.cn/article/Prometheus-theory-source-code" target="_blank" rel="noopener">https://www.infoq.cn/article/Prometheus-theory-source-code</a></p><p>源码解析：<a href="https://blog.csdn.net/qingyuanluofeng/article/details/84779737" target="_blank" rel="noopener">https://blog.csdn.net/qingyuanluofeng/article/details/84779737</a></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/prometheus-exporter/" rel="tag"># prometheus, exporter</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/archives/7f473fb4.html" rel="next" title="All This I Did Without You"><i class="fa fa-chevron-left"></i> All This I Did Without You</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示 Gitment 评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">haoxiaoci</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/haoxiaoci" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务的功能"><span class="nav-number">1.1.</span> <span class="nav-text">服务的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码地址"><span class="nav-number">1.2.</span> <span class="nav-text">代码地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#它是怎么工作的"><span class="nav-number">1.3.</span> <span class="nav-text">它是怎么工作的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码"><span class="nav-number">2.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于prometheus-client需要知道的这些"><span class="nav-number">2.1.</span> <span class="nav-text">关于prometheus_client需要知道的这些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码层逻辑实现"><span class="nav-number">2.2.</span> <span class="nav-text">代码层逻辑实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从程序入口开始"><span class="nav-number">2.3.</span> <span class="nav-text">从程序入口开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开启线程，收集集群数据-DataGatherer-Thread"><span class="nav-number">2.4.</span> <span class="nav-text">开启线程，收集集群数据 | DataGatherer(Thread)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPServer的框架-ForkingHTTPServer"><span class="nav-number">2.5.</span> <span class="nav-text">HTTPServer的框架 | ForkingHTTPServer(..)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取client-get-clients"><span class="nav-number">2.6.</span> <span class="nav-text">获取client | get_clients()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#来看看handler怎么处理给客户端返回数据的-OpenstackExporterHandler"><span class="nav-number">2.7.</span> <span class="nav-text">来看看handler怎么处理给客户端返回数据的 |OpenstackExporterHandler(..)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#来看一个Collector是怎么收集数据的-Nova"><span class="nav-number">2.8.</span> <span class="nav-text">来看一个Collector是怎么收集数据的 | Nova()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#所有的metrics列表"><span class="nav-number">2.9.</span> <span class="nav-text">所有的metrics列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grafana-dashboard"><span class="nav-number">3.</span> <span class="nav-text">grafana-dashboard</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-haoxiaoci"></i> </span><span class="author" itemprop="copyrightHolder">haoxiaoci</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:100,height:200},mobile:{show:!1},log:!1,tagMode:!1})</script></body></html><!-- rebuild by neat -->